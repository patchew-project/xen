// DO NOT EDIT.
//
// This file is generated by:
// gengotypes.py ../../libxl/libxl_types.idl
//
package xenlight

import (
	"errors"
	"fmt"
	"unsafe"
)

/*
#cgo LDFLAGS: -lxenlight
#include <stdlib.h>
#include <libxl.h>

typedef typeof(((struct libxl_channelinfo *)NULL)->u.pty)libxl_channelinfo_connection_union_pty;
typedef typeof(((struct libxl_domain_build_info *)NULL)->u.hvm)libxl_domain_build_info_type_union_hvm;
typedef typeof(((struct libxl_domain_build_info *)NULL)->u.pv)libxl_domain_build_info_type_union_pv;
typedef typeof(((struct libxl_domain_build_info *)NULL)->u.pvh)libxl_domain_build_info_type_union_pvh;
typedef typeof(((struct libxl_device_usbdev *)NULL)->u.hostdev)libxl_device_usbdev_type_union_hostdev;
typedef typeof(((struct libxl_device_channel *)NULL)->u.socket)libxl_device_channel_connection_union_socket;
typedef typeof(((struct libxl_event *)NULL)->u.domain_shutdown)libxl_event_type_union_domain_shutdown;
typedef typeof(((struct libxl_event *)NULL)->u.disk_eject)libxl_event_type_union_disk_eject;
typedef typeof(((struct libxl_event *)NULL)->u.operation_complete)libxl_event_type_union_operation_complete;
typedef typeof(((struct libxl_psr_hw_info *)NULL)->u.cat)libxl_psr_hw_info_type_union_cat;
typedef typeof(((struct libxl_psr_hw_info *)NULL)->u.mba)libxl_psr_hw_info_type_union_mba;
*/
import "C"

func (x *IoportRange) fromC(xc *C.libxl_ioport_range) error {
	x.First = uint32(xc.first)
	x.Number = uint32(xc.number)

	return nil
}

func (x *IoportRange) toC() (xc C.libxl_ioport_range, err error) {
	C.libxl_ioport_range_init(&xc)
	xc.first = C.uint32_t(x.First)
	xc.number = C.uint32_t(x.Number)
	return xc, nil
}

func (x *IomemRange) fromC(xc *C.libxl_iomem_range) error {
	x.Start = uint64(xc.start)
	x.Number = uint64(xc.number)
	x.Gfn = uint64(xc.gfn)

	return nil
}

func (x *IomemRange) toC() (xc C.libxl_iomem_range, err error) {
	C.libxl_iomem_range_init(&xc)
	xc.start = C.uint64_t(x.Start)
	xc.number = C.uint64_t(x.Number)
	xc.gfn = C.uint64_t(x.Gfn)
	return xc, nil
}

func (x *VgaInterfaceInfo) fromC(xc *C.libxl_vga_interface_info) error {
	x.Kind = VgaInterfaceType(xc.kind)

	return nil
}

func (x *VgaInterfaceInfo) toC() (xc C.libxl_vga_interface_info, err error) {
	C.libxl_vga_interface_info_init(&xc)
	xc.kind = C.libxl_vga_interface_type(x.Kind)
	return xc, nil
}

func (x *VncInfo) fromC(xc *C.libxl_vnc_info) error {
	if err := x.Enable.fromC(&xc.enable); err != nil {
		return err
	}
	x.Listen = C.GoString(xc.listen)
	x.Passwd = C.GoString(xc.passwd)
	x.Display = int(xc.display)
	if err := x.Findunused.fromC(&xc.findunused); err != nil {
		return err
	}

	return nil
}

func (x *VncInfo) toC() (xc C.libxl_vnc_info, err error) {
	C.libxl_vnc_info_init(&xc)
	xc.enable, err = x.Enable.toC()
	if err != nil {
		C.libxl_vnc_info_dispose(&xc)
		return xc, err
	}
	xc.listen = C.CString(x.Listen)
	xc.passwd = C.CString(x.Passwd)
	xc.display = C.int(x.Display)
	xc.findunused, err = x.Findunused.toC()
	if err != nil {
		C.libxl_vnc_info_dispose(&xc)
		return xc, err
	}
	return xc, nil
}

func (x *SpiceInfo) fromC(xc *C.libxl_spice_info) error {
	if err := x.Enable.fromC(&xc.enable); err != nil {
		return err
	}
	x.Port = int(xc.port)
	x.TlsPort = int(xc.tls_port)
	x.Host = C.GoString(xc.host)
	if err := x.DisableTicketing.fromC(&xc.disable_ticketing); err != nil {
		return err
	}
	x.Passwd = C.GoString(xc.passwd)
	if err := x.AgentMouse.fromC(&xc.agent_mouse); err != nil {
		return err
	}
	if err := x.Vdagent.fromC(&xc.vdagent); err != nil {
		return err
	}
	if err := x.ClipboardSharing.fromC(&xc.clipboard_sharing); err != nil {
		return err
	}
	x.Usbredirection = int(xc.usbredirection)
	x.ImageCompression = C.GoString(xc.image_compression)
	x.StreamingVideo = C.GoString(xc.streaming_video)

	return nil
}

func (x *SpiceInfo) toC() (xc C.libxl_spice_info, err error) {
	C.libxl_spice_info_init(&xc)
	xc.enable, err = x.Enable.toC()
	if err != nil {
		C.libxl_spice_info_dispose(&xc)
		return xc, err
	}
	xc.port = C.int(x.Port)
	xc.tls_port = C.int(x.TlsPort)
	xc.host = C.CString(x.Host)
	xc.disable_ticketing, err = x.DisableTicketing.toC()
	if err != nil {
		C.libxl_spice_info_dispose(&xc)
		return xc, err
	}
	xc.passwd = C.CString(x.Passwd)
	xc.agent_mouse, err = x.AgentMouse.toC()
	if err != nil {
		C.libxl_spice_info_dispose(&xc)
		return xc, err
	}
	xc.vdagent, err = x.Vdagent.toC()
	if err != nil {
		C.libxl_spice_info_dispose(&xc)
		return xc, err
	}
	xc.clipboard_sharing, err = x.ClipboardSharing.toC()
	if err != nil {
		C.libxl_spice_info_dispose(&xc)
		return xc, err
	}
	xc.usbredirection = C.int(x.Usbredirection)
	xc.image_compression = C.CString(x.ImageCompression)
	xc.streaming_video = C.CString(x.StreamingVideo)
	return xc, nil
}

func (x *SdlInfo) fromC(xc *C.libxl_sdl_info) error {
	if err := x.Enable.fromC(&xc.enable); err != nil {
		return err
	}
	if err := x.Opengl.fromC(&xc.opengl); err != nil {
		return err
	}
	x.Display = C.GoString(xc.display)
	x.Xauthority = C.GoString(xc.xauthority)

	return nil
}

func (x *SdlInfo) toC() (xc C.libxl_sdl_info, err error) {
	C.libxl_sdl_info_init(&xc)
	xc.enable, err = x.Enable.toC()
	if err != nil {
		C.libxl_sdl_info_dispose(&xc)
		return xc, err
	}
	xc.opengl, err = x.Opengl.toC()
	if err != nil {
		C.libxl_sdl_info_dispose(&xc)
		return xc, err
	}
	xc.display = C.CString(x.Display)
	xc.xauthority = C.CString(x.Xauthority)
	return xc, nil
}

func (x *Dominfo) fromC(xc *C.libxl_dominfo) error {
	if err := x.Uuid.fromC(&xc.uuid); err != nil {
		return err
	}
	x.Domid = Domid(xc.domid)
	x.Ssidref = uint32(xc.ssidref)
	x.SsidLabel = C.GoString(xc.ssid_label)
	x.Running = bool(xc.running)
	x.Blocked = bool(xc.blocked)
	x.Paused = bool(xc.paused)
	x.Shutdown = bool(xc.shutdown)
	x.Dying = bool(xc.dying)
	x.NeverStop = bool(xc.never_stop)
	x.ShutdownReason = ShutdownReason(xc.shutdown_reason)
	x.OutstandingMemkb = uint64(xc.outstanding_memkb)
	x.CurrentMemkb = uint64(xc.current_memkb)
	x.SharedMemkb = uint64(xc.shared_memkb)
	x.PagedMemkb = uint64(xc.paged_memkb)
	x.MaxMemkb = uint64(xc.max_memkb)
	x.CpuTime = uint64(xc.cpu_time)
	x.VcpuMaxId = uint32(xc.vcpu_max_id)
	x.VcpuOnline = uint32(xc.vcpu_online)
	x.Cpupool = uint32(xc.cpupool)
	x.DomainType = DomainType(xc.domain_type)

	return nil
}

func (x *Dominfo) toC() (xc C.libxl_dominfo, err error) {
	C.libxl_dominfo_init(&xc)
	xc.uuid, err = x.Uuid.toC()
	if err != nil {
		C.libxl_dominfo_dispose(&xc)
		return xc, err
	}
	xc.domid = C.libxl_domid(x.Domid)
	xc.ssidref = C.uint32_t(x.Ssidref)
	xc.ssid_label = C.CString(x.SsidLabel)
	xc.running = C.bool(x.Running)
	xc.blocked = C.bool(x.Blocked)
	xc.paused = C.bool(x.Paused)
	xc.shutdown = C.bool(x.Shutdown)
	xc.dying = C.bool(x.Dying)
	xc.never_stop = C.bool(x.NeverStop)
	xc.shutdown_reason = C.libxl_shutdown_reason(x.ShutdownReason)
	xc.outstanding_memkb = C.uint64_t(x.OutstandingMemkb)
	xc.current_memkb = C.uint64_t(x.CurrentMemkb)
	xc.shared_memkb = C.uint64_t(x.SharedMemkb)
	xc.paged_memkb = C.uint64_t(x.PagedMemkb)
	xc.max_memkb = C.uint64_t(x.MaxMemkb)
	xc.cpu_time = C.uint64_t(x.CpuTime)
	xc.vcpu_max_id = C.uint32_t(x.VcpuMaxId)
	xc.vcpu_online = C.uint32_t(x.VcpuOnline)
	xc.cpupool = C.uint32_t(x.Cpupool)
	xc.domain_type = C.libxl_domain_type(x.DomainType)
	return xc, nil
}

func (x *Cpupoolinfo) fromC(xc *C.libxl_cpupoolinfo) error {
	x.Poolid = uint32(xc.poolid)
	x.PoolName = C.GoString(xc.pool_name)
	x.Sched = Scheduler(xc.sched)
	x.NDom = uint32(xc.n_dom)
	if err := x.Cpumap.fromC(&xc.cpumap); err != nil {
		return err
	}

	return nil
}

func (x *Cpupoolinfo) toC() (xc C.libxl_cpupoolinfo, err error) {
	C.libxl_cpupoolinfo_init(&xc)
	xc.poolid = C.uint32_t(x.Poolid)
	xc.pool_name = C.CString(x.PoolName)
	xc.sched = C.libxl_scheduler(x.Sched)
	xc.n_dom = C.uint32_t(x.NDom)
	xc.cpumap, err = x.Cpumap.toC()
	if err != nil {
		C.libxl_cpupoolinfo_dispose(&xc)
		return xc, err
	}
	return xc, nil
}

func (x *Channelinfo) fromC(xc *C.libxl_channelinfo) error {
	x.Backend = C.GoString(xc.backend)
	x.BackendId = uint32(xc.backend_id)
	x.Frontend = C.GoString(xc.frontend)
	x.FrontendId = uint32(xc.frontend_id)
	x.Devid = Devid(xc.devid)
	x.State = int(xc.state)
	x.Evtch = int(xc.evtch)
	x.Rref = int(xc.rref)
	x.Connection = ChannelConnection(xc.connection)
	switch x.Connection {
	case ChannelConnectionPty:
		var connectionPty ChannelinfoConnectionUnionPty
		if err := connectionPty.fromC(xc); err != nil {
			return err
		}
		x.ConnectionUnion = connectionPty
	default:
		return fmt.Errorf("invalid union key '%v'", x.Connection)
	}

	return nil
}

func (x *ChannelinfoConnectionUnionPty) fromC(xc *C.libxl_channelinfo) error {
	if ChannelConnection(xc.connection) != ChannelConnectionPty {
		return errors.New("expected union key ChannelConnectionPty")
	}

	tmp := (*C.libxl_channelinfo_connection_union_pty)(unsafe.Pointer(&xc.u[0]))
	x.Path = C.GoString(tmp.path)
	return nil
}

func (x *Channelinfo) toC() (xc C.libxl_channelinfo, err error) {
	C.libxl_channelinfo_init(&xc)
	xc.backend = C.CString(x.Backend)
	xc.backend_id = C.uint32_t(x.BackendId)
	xc.frontend = C.CString(x.Frontend)
	xc.frontend_id = C.uint32_t(x.FrontendId)
	xc.devid = C.libxl_devid(x.Devid)
	xc.state = C.int(x.State)
	xc.evtch = C.int(x.Evtch)
	xc.rref = C.int(x.Rref)
	xc.connection = C.libxl_channel_connection(x.Connection)
	switch x.Connection {
	case ChannelConnectionPty:
		tmp, ok := x.ConnectionUnion.(ChannelinfoConnectionUnionPty)
		if !ok {
			C.libxl_channelinfo_dispose(&xc)
			return xc, errors.New("wrong type for union key connection")
		}
		var pty C.libxl_channelinfo_connection_union_pty
		pty.path = C.CString(tmp.Path)
		ptyBytes := C.GoBytes(unsafe.Pointer(&pty), C.sizeof_libxl_channelinfo_connection_union_pty)
		copy(xc.u[:], ptyBytes)
	default:
		return xc, fmt.Errorf("invalid union key '%v'", x.Connection)
	}
	return xc, nil
}

func (x *Vminfo) fromC(xc *C.libxl_vminfo) error {
	if err := x.Uuid.fromC(&xc.uuid); err != nil {
		return err
	}
	x.Domid = Domid(xc.domid)

	return nil
}

func (x *Vminfo) toC() (xc C.libxl_vminfo, err error) {
	C.libxl_vminfo_init(&xc)
	xc.uuid, err = x.Uuid.toC()
	if err != nil {
		C.libxl_vminfo_dispose(&xc)
		return xc, err
	}
	xc.domid = C.libxl_domid(x.Domid)
	return xc, nil
}

func (x *VersionInfo) fromC(xc *C.libxl_version_info) error {
	x.XenVersionMajor = int(xc.xen_version_major)
	x.XenVersionMinor = int(xc.xen_version_minor)
	x.XenVersionExtra = C.GoString(xc.xen_version_extra)
	x.Compiler = C.GoString(xc.compiler)
	x.CompileBy = C.GoString(xc.compile_by)
	x.CompileDomain = C.GoString(xc.compile_domain)
	x.CompileDate = C.GoString(xc.compile_date)
	x.Capabilities = C.GoString(xc.capabilities)
	x.Changeset = C.GoString(xc.changeset)
	x.VirtStart = uint64(xc.virt_start)
	x.Pagesize = int(xc.pagesize)
	x.Commandline = C.GoString(xc.commandline)
	x.BuildId = C.GoString(xc.build_id)

	return nil
}

func (x *VersionInfo) toC() (xc C.libxl_version_info, err error) {
	C.libxl_version_info_init(&xc)
	xc.xen_version_major = C.int(x.XenVersionMajor)
	xc.xen_version_minor = C.int(x.XenVersionMinor)
	xc.xen_version_extra = C.CString(x.XenVersionExtra)
	xc.compiler = C.CString(x.Compiler)
	xc.compile_by = C.CString(x.CompileBy)
	xc.compile_domain = C.CString(x.CompileDomain)
	xc.compile_date = C.CString(x.CompileDate)
	xc.capabilities = C.CString(x.Capabilities)
	xc.changeset = C.CString(x.Changeset)
	xc.virt_start = C.uint64_t(x.VirtStart)
	xc.pagesize = C.int(x.Pagesize)
	xc.commandline = C.CString(x.Commandline)
	xc.build_id = C.CString(x.BuildId)
	return xc, nil
}

func (x *DomainCreateInfo) fromC(xc *C.libxl_domain_create_info) error {
	x.Type = DomainType(xc._type)
	if err := x.Hap.fromC(&xc.hap); err != nil {
		return err
	}
	if err := x.Oos.fromC(&xc.oos); err != nil {
		return err
	}
	x.Ssidref = uint32(xc.ssidref)
	x.SsidLabel = C.GoString(xc.ssid_label)
	x.Name = C.GoString(xc.name)
	if err := x.Uuid.fromC(&xc.uuid); err != nil {
		return err
	}
	if err := x.Xsdata.fromC(&xc.xsdata); err != nil {
		return err
	}
	if err := x.Platformdata.fromC(&xc.platformdata); err != nil {
		return err
	}
	x.Poolid = uint32(xc.poolid)
	x.PoolName = C.GoString(xc.pool_name)
	if err := x.RunHotplugScripts.fromC(&xc.run_hotplug_scripts); err != nil {
		return err
	}
	if err := x.DriverDomain.fromC(&xc.driver_domain); err != nil {
		return err
	}
	x.Passthrough = Passthrough(xc.passthrough)

	return nil
}

func (x *DomainCreateInfo) toC() (xc C.libxl_domain_create_info, err error) {
	C.libxl_domain_create_info_init(&xc)
	xc._type = C.libxl_domain_type(x.Type)
	xc.hap, err = x.Hap.toC()
	if err != nil {
		C.libxl_domain_create_info_dispose(&xc)
		return xc, err
	}
	xc.oos, err = x.Oos.toC()
	if err != nil {
		C.libxl_domain_create_info_dispose(&xc)
		return xc, err
	}
	xc.ssidref = C.uint32_t(x.Ssidref)
	xc.ssid_label = C.CString(x.SsidLabel)
	xc.name = C.CString(x.Name)
	xc.uuid, err = x.Uuid.toC()
	if err != nil {
		C.libxl_domain_create_info_dispose(&xc)
		return xc, err
	}
	xc.xsdata, err = x.Xsdata.toC()
	if err != nil {
		C.libxl_domain_create_info_dispose(&xc)
		return xc, err
	}
	xc.platformdata, err = x.Platformdata.toC()
	if err != nil {
		C.libxl_domain_create_info_dispose(&xc)
		return xc, err
	}
	xc.poolid = C.uint32_t(x.Poolid)
	xc.pool_name = C.CString(x.PoolName)
	xc.run_hotplug_scripts, err = x.RunHotplugScripts.toC()
	if err != nil {
		C.libxl_domain_create_info_dispose(&xc)
		return xc, err
	}
	xc.driver_domain, err = x.DriverDomain.toC()
	if err != nil {
		C.libxl_domain_create_info_dispose(&xc)
		return xc, err
	}
	xc.passthrough = C.libxl_passthrough(x.Passthrough)
	return xc, nil
}

func (x *DomainRestoreParams) fromC(xc *C.libxl_domain_restore_params) error {
	x.CheckpointedStream = int(xc.checkpointed_stream)
	x.StreamVersion = uint32(xc.stream_version)
	x.ColoProxyScript = C.GoString(xc.colo_proxy_script)
	if err := x.UserspaceColoProxy.fromC(&xc.userspace_colo_proxy); err != nil {
		return err
	}

	return nil
}

func (x *DomainRestoreParams) toC() (xc C.libxl_domain_restore_params, err error) {
	C.libxl_domain_restore_params_init(&xc)
	xc.checkpointed_stream = C.int(x.CheckpointedStream)
	xc.stream_version = C.uint32_t(x.StreamVersion)
	xc.colo_proxy_script = C.CString(x.ColoProxyScript)
	xc.userspace_colo_proxy, err = x.UserspaceColoProxy.toC()
	if err != nil {
		C.libxl_domain_restore_params_dispose(&xc)
		return xc, err
	}
	return xc, nil
}

func (x *SchedParams) fromC(xc *C.libxl_sched_params) error {
	x.Vcpuid = int(xc.vcpuid)
	x.Weight = int(xc.weight)
	x.Cap = int(xc.cap)
	x.Period = int(xc.period)
	x.Extratime = int(xc.extratime)
	x.Budget = int(xc.budget)

	return nil
}

func (x *SchedParams) toC() (xc C.libxl_sched_params, err error) {
	C.libxl_sched_params_init(&xc)
	xc.vcpuid = C.int(x.Vcpuid)
	xc.weight = C.int(x.Weight)
	xc.cap = C.int(x.Cap)
	xc.period = C.int(x.Period)
	xc.extratime = C.int(x.Extratime)
	xc.budget = C.int(x.Budget)
	return xc, nil
}

func (x *VcpuSchedParams) fromC(xc *C.libxl_vcpu_sched_params) error {
	x.Sched = Scheduler(xc.sched)
	numVcpus := int(xc.num_vcpus)
	cVcpus := (*[1 << 28]C.libxl_sched_params)(unsafe.Pointer(xc.vcpus))[:numVcpus:numVcpus]
	x.Vcpus = make([]SchedParams, numVcpus)
	for i, v := range cVcpus {
		var e SchedParams
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Vcpus[i] = e
	}

	return nil
}

func (x *VcpuSchedParams) toC() (xc C.libxl_vcpu_sched_params, err error) {
	C.libxl_vcpu_sched_params_init(&xc)
	xc.sched = C.libxl_scheduler(x.Sched)
	numVcpus := len(x.Vcpus)
	xc.vcpus = (*C.libxl_sched_params)(C.malloc(C.ulong(numVcpus) * C.sizeof_libxl_sched_params))
	xc.num_vcpus = C.int(numVcpus)
	cVcpus := (*[1 << 28]C.libxl_sched_params)(unsafe.Pointer(xc.vcpus))[:numVcpus:numVcpus]
	for i, v := range x.Vcpus {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_vcpu_sched_params_dispose(&xc)
			return xc, err
		}
		cVcpus[i] = tmp
	}
	return xc, nil
}

func (x *DomainSchedParams) fromC(xc *C.libxl_domain_sched_params) error {
	x.Sched = Scheduler(xc.sched)
	x.Weight = int(xc.weight)
	x.Cap = int(xc.cap)
	x.Period = int(xc.period)
	x.Budget = int(xc.budget)
	x.Extratime = int(xc.extratime)
	x.Slice = int(xc.slice)
	x.Latency = int(xc.latency)

	return nil
}

func (x *DomainSchedParams) toC() (xc C.libxl_domain_sched_params, err error) {
	C.libxl_domain_sched_params_init(&xc)
	xc.sched = C.libxl_scheduler(x.Sched)
	xc.weight = C.int(x.Weight)
	xc.cap = C.int(x.Cap)
	xc.period = C.int(x.Period)
	xc.budget = C.int(x.Budget)
	xc.extratime = C.int(x.Extratime)
	xc.slice = C.int(x.Slice)
	xc.latency = C.int(x.Latency)
	return xc, nil
}

func (x *VnodeInfo) fromC(xc *C.libxl_vnode_info) error {
	x.Memkb = uint64(xc.memkb)
	numDistances := int(xc.num_distances)
	cDistances := (*[1 << 28]C.uint32_t)(unsafe.Pointer(xc.distances))[:numDistances:numDistances]
	x.Distances = make([]uint32, numDistances)
	for i, v := range cDistances {
		x.Distances[i] = uint32(v)
	}
	x.Pnode = uint32(xc.pnode)
	if err := x.Vcpus.fromC(&xc.vcpus); err != nil {
		return err
	}

	return nil
}

func (x *VnodeInfo) toC() (xc C.libxl_vnode_info, err error) {
	C.libxl_vnode_info_init(&xc)
	xc.memkb = C.uint64_t(x.Memkb)
	numDistances := len(x.Distances)
	xc.distances = (*C.uint32_t)(C.malloc(C.size_t(numDistances * numDistances)))
	xc.num_distances = C.int(numDistances)
	cDistances := (*[1 << 28]C.uint32_t)(unsafe.Pointer(xc.distances))[:numDistances:numDistances]
	for i, v := range x.Distances {
		cDistances[i] = C.uint32_t(v)
	}
	xc.pnode = C.uint32_t(x.Pnode)
	xc.vcpus, err = x.Vcpus.toC()
	if err != nil {
		C.libxl_vnode_info_dispose(&xc)
		return xc, err
	}
	return xc, nil
}

func (x *RdmReserve) fromC(xc *C.libxl_rdm_reserve) error {
	x.Strategy = RdmReserveStrategy(xc.strategy)
	x.Policy = RdmReservePolicy(xc.policy)

	return nil
}

func (x *RdmReserve) toC() (xc C.libxl_rdm_reserve, err error) {
	C.libxl_rdm_reserve_init(&xc)
	xc.strategy = C.libxl_rdm_reserve_strategy(x.Strategy)
	xc.policy = C.libxl_rdm_reserve_policy(x.Policy)
	return xc, nil
}

func (x *DomainBuildInfo) fromC(xc *C.libxl_domain_build_info) error {
	x.MaxVcpus = int(xc.max_vcpus)
	if err := x.AvailVcpus.fromC(&xc.avail_vcpus); err != nil {
		return err
	}
	if err := x.Cpumap.fromC(&xc.cpumap); err != nil {
		return err
	}
	if err := x.Nodemap.fromC(&xc.nodemap); err != nil {
		return err
	}
	numVcpuHardAffinity := int(xc.num_vcpu_hard_affinity)
	cVcpuHardAffinity := (*[1 << 28]C.libxl_bitmap)(unsafe.Pointer(xc.vcpu_hard_affinity))[:numVcpuHardAffinity:numVcpuHardAffinity]
	x.VcpuHardAffinity = make([]Bitmap, numVcpuHardAffinity)
	for i, v := range cVcpuHardAffinity {
		var e Bitmap
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.VcpuHardAffinity[i] = e
	}
	numVcpuSoftAffinity := int(xc.num_vcpu_soft_affinity)
	cVcpuSoftAffinity := (*[1 << 28]C.libxl_bitmap)(unsafe.Pointer(xc.vcpu_soft_affinity))[:numVcpuSoftAffinity:numVcpuSoftAffinity]
	x.VcpuSoftAffinity = make([]Bitmap, numVcpuSoftAffinity)
	for i, v := range cVcpuSoftAffinity {
		var e Bitmap
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.VcpuSoftAffinity[i] = e
	}
	if err := x.NumaPlacement.fromC(&xc.numa_placement); err != nil {
		return err
	}
	x.TscMode = TscMode(xc.tsc_mode)
	x.MaxMemkb = uint64(xc.max_memkb)
	x.TargetMemkb = uint64(xc.target_memkb)
	x.VideoMemkb = uint64(xc.video_memkb)
	x.ShadowMemkb = uint64(xc.shadow_memkb)
	x.IommuMemkb = uint64(xc.iommu_memkb)
	x.RtcTimeoffset = uint32(xc.rtc_timeoffset)
	x.ExecSsidref = uint32(xc.exec_ssidref)
	x.ExecSsidLabel = C.GoString(xc.exec_ssid_label)
	if err := x.Localtime.fromC(&xc.localtime); err != nil {
		return err
	}
	if err := x.DisableMigrate.fromC(&xc.disable_migrate); err != nil {
		return err
	}
	if err := x.Cpuid.fromC(&xc.cpuid); err != nil {
		return err
	}
	x.BlkdevStart = C.GoString(xc.blkdev_start)
	numVnumaNodes := int(xc.num_vnuma_nodes)
	cVnumaNodes := (*[1 << 28]C.libxl_vnode_info)(unsafe.Pointer(xc.vnuma_nodes))[:numVnumaNodes:numVnumaNodes]
	x.VnumaNodes = make([]VnodeInfo, numVnumaNodes)
	for i, v := range cVnumaNodes {
		var e VnodeInfo
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.VnumaNodes[i] = e
	}
	x.MaxGrantFrames = uint32(xc.max_grant_frames)
	x.MaxMaptrackFrames = uint32(xc.max_maptrack_frames)
	x.DeviceModelVersion = DeviceModelVersion(xc.device_model_version)
	if err := x.DeviceModelStubdomain.fromC(&xc.device_model_stubdomain); err != nil {
		return err
	}
	x.DeviceModel = C.GoString(xc.device_model)
	x.DeviceModelSsidref = uint32(xc.device_model_ssidref)
	x.DeviceModelSsidLabel = C.GoString(xc.device_model_ssid_label)
	x.DeviceModelUser = C.GoString(xc.device_model_user)
	if err := x.Extra.fromC(&xc.extra); err != nil {
		return err
	}
	if err := x.ExtraPv.fromC(&xc.extra_pv); err != nil {
		return err
	}
	if err := x.ExtraHvm.fromC(&xc.extra_hvm); err != nil {
		return err
	}
	if err := x.SchedParams.fromC(&xc.sched_params); err != nil {
		return err
	}
	numIoports := int(xc.num_ioports)
	cIoports := (*[1 << 28]C.libxl_ioport_range)(unsafe.Pointer(xc.ioports))[:numIoports:numIoports]
	x.Ioports = make([]IoportRange, numIoports)
	for i, v := range cIoports {
		var e IoportRange
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Ioports[i] = e
	}
	numIrqs := int(xc.num_irqs)
	cIrqs := (*[1 << 28]C.uint32_t)(unsafe.Pointer(xc.irqs))[:numIrqs:numIrqs]
	x.Irqs = make([]uint32, numIrqs)
	for i, v := range cIrqs {
		x.Irqs[i] = uint32(v)
	}
	numIomem := int(xc.num_iomem)
	cIomem := (*[1 << 28]C.libxl_iomem_range)(unsafe.Pointer(xc.iomem))[:numIomem:numIomem]
	x.Iomem = make([]IomemRange, numIomem)
	for i, v := range cIomem {
		var e IomemRange
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Iomem[i] = e
	}
	if err := x.ClaimMode.fromC(&xc.claim_mode); err != nil {
		return err
	}
	x.EventChannels = uint32(xc.event_channels)
	x.Kernel = C.GoString(xc.kernel)
	x.Cmdline = C.GoString(xc.cmdline)
	x.Ramdisk = C.GoString(xc.ramdisk)
	x.DeviceTree = C.GoString(xc.device_tree)
	if err := x.Acpi.fromC(&xc.acpi); err != nil {
		return err
	}
	x.Bootloader = C.GoString(xc.bootloader)
	if err := x.BootloaderArgs.fromC(&xc.bootloader_args); err != nil {
		return err
	}
	x.TimerMode = TimerMode(xc.timer_mode)
	if err := x.NestedHvm.fromC(&xc.nested_hvm); err != nil {
		return err
	}
	if err := x.Apic.fromC(&xc.apic); err != nil {
		return err
	}
	if err := x.DmRestrict.fromC(&xc.dm_restrict); err != nil {
		return err
	}
	x.Tee = TeeType(xc.tee)
	x.Type = DomainType(xc._type)
	switch x.Type {
	case DomainTypePv:
		var typePv DomainBuildInfoTypeUnionPv
		if err := typePv.fromC(xc); err != nil {
			return err
		}
		x.TypeUnion = typePv
	case DomainTypeHvm:
		var typeHvm DomainBuildInfoTypeUnionHvm
		if err := typeHvm.fromC(xc); err != nil {
			return err
		}
		x.TypeUnion = typeHvm
	case DomainTypePvh:
		var typePvh DomainBuildInfoTypeUnionPvh
		if err := typePvh.fromC(xc); err != nil {
			return err
		}
		x.TypeUnion = typePvh
	default:
		return fmt.Errorf("invalid union key '%v'", x.Type)
	}
	x.ArchArm.GicVersion = GicVersion(xc.arch_arm.gic_version)
	x.ArchArm.Vuart = VuartType(xc.arch_arm.vuart)
	x.Altp2M = Altp2MMode(xc.altp2m)

	return nil
}

func (x *DomainBuildInfoTypeUnionHvm) fromC(xc *C.libxl_domain_build_info) error {
	if DomainType(xc._type) != DomainTypeHvm {
		return errors.New("expected union key DomainTypeHvm")
	}

	tmp := (*C.libxl_domain_build_info_type_union_hvm)(unsafe.Pointer(&xc.u[0]))
	x.Firmware = C.GoString(tmp.firmware)
	x.Bios = BiosType(tmp.bios)
	if err := x.Pae.fromC(&tmp.pae); err != nil {
		return err
	}
	if err := x.Apic.fromC(&tmp.apic); err != nil {
		return err
	}
	if err := x.Acpi.fromC(&tmp.acpi); err != nil {
		return err
	}
	if err := x.AcpiS3.fromC(&tmp.acpi_s3); err != nil {
		return err
	}
	if err := x.AcpiS4.fromC(&tmp.acpi_s4); err != nil {
		return err
	}
	if err := x.AcpiLaptopSlate.fromC(&tmp.acpi_laptop_slate); err != nil {
		return err
	}
	if err := x.Nx.fromC(&tmp.nx); err != nil {
		return err
	}
	if err := x.Viridian.fromC(&tmp.viridian); err != nil {
		return err
	}
	if err := x.ViridianEnable.fromC(&tmp.viridian_enable); err != nil {
		return err
	}
	if err := x.ViridianDisable.fromC(&tmp.viridian_disable); err != nil {
		return err
	}
	x.Timeoffset = C.GoString(tmp.timeoffset)
	if err := x.Hpet.fromC(&tmp.hpet); err != nil {
		return err
	}
	if err := x.VptAlign.fromC(&tmp.vpt_align); err != nil {
		return err
	}
	x.MmioHoleMemkb = uint64(tmp.mmio_hole_memkb)
	x.TimerMode = TimerMode(tmp.timer_mode)
	if err := x.NestedHvm.fromC(&tmp.nested_hvm); err != nil {
		return err
	}
	if err := x.Altp2M.fromC(&tmp.altp2m); err != nil {
		return err
	}
	x.SystemFirmware = C.GoString(tmp.system_firmware)
	x.SmbiosFirmware = C.GoString(tmp.smbios_firmware)
	x.AcpiFirmware = C.GoString(tmp.acpi_firmware)
	x.Hdtype = Hdtype(tmp.hdtype)
	if err := x.Nographic.fromC(&tmp.nographic); err != nil {
		return err
	}
	if err := x.Vga.fromC(&tmp.vga); err != nil {
		return err
	}
	if err := x.Vnc.fromC(&tmp.vnc); err != nil {
		return err
	}
	x.Keymap = C.GoString(tmp.keymap)
	if err := x.Sdl.fromC(&tmp.sdl); err != nil {
		return err
	}
	if err := x.Spice.fromC(&tmp.spice); err != nil {
		return err
	}
	if err := x.GfxPassthru.fromC(&tmp.gfx_passthru); err != nil {
		return err
	}
	x.GfxPassthruKind = GfxPassthruKind(tmp.gfx_passthru_kind)
	x.Serial = C.GoString(tmp.serial)
	x.Boot = C.GoString(tmp.boot)
	if err := x.Usb.fromC(&tmp.usb); err != nil {
		return err
	}
	x.Usbversion = int(tmp.usbversion)
	x.Usbdevice = C.GoString(tmp.usbdevice)
	if err := x.VkbDevice.fromC(&tmp.vkb_device); err != nil {
		return err
	}
	x.Soundhw = C.GoString(tmp.soundhw)
	if err := x.XenPlatformPci.fromC(&tmp.xen_platform_pci); err != nil {
		return err
	}
	if err := x.UsbdeviceList.fromC(&tmp.usbdevice_list); err != nil {
		return err
	}
	x.VendorDevice = VendorDevice(tmp.vendor_device)
	if err := x.MsVmGenid.fromC(&tmp.ms_vm_genid); err != nil {
		return err
	}
	if err := x.SerialList.fromC(&tmp.serial_list); err != nil {
		return err
	}
	if err := x.Rdm.fromC(&tmp.rdm); err != nil {
		return err
	}
	x.RdmMemBoundaryMemkb = uint64(tmp.rdm_mem_boundary_memkb)
	x.McaCaps = uint64(tmp.mca_caps)
	return nil
}

func (x *DomainBuildInfoTypeUnionPv) fromC(xc *C.libxl_domain_build_info) error {
	if DomainType(xc._type) != DomainTypePv {
		return errors.New("expected union key DomainTypePv")
	}

	tmp := (*C.libxl_domain_build_info_type_union_pv)(unsafe.Pointer(&xc.u[0]))
	x.Kernel = C.GoString(tmp.kernel)
	x.SlackMemkb = uint64(tmp.slack_memkb)
	x.Bootloader = C.GoString(tmp.bootloader)
	if err := x.BootloaderArgs.fromC(&tmp.bootloader_args); err != nil {
		return err
	}
	x.Cmdline = C.GoString(tmp.cmdline)
	x.Ramdisk = C.GoString(tmp.ramdisk)
	x.Features = C.GoString(tmp.features)
	if err := x.E820Host.fromC(&tmp.e820_host); err != nil {
		return err
	}
	return nil
}

func (x *DomainBuildInfoTypeUnionPvh) fromC(xc *C.libxl_domain_build_info) error {
	if DomainType(xc._type) != DomainTypePvh {
		return errors.New("expected union key DomainTypePvh")
	}

	tmp := (*C.libxl_domain_build_info_type_union_pvh)(unsafe.Pointer(&xc.u[0]))
	if err := x.Pvshim.fromC(&tmp.pvshim); err != nil {
		return err
	}
	x.PvshimPath = C.GoString(tmp.pvshim_path)
	x.PvshimCmdline = C.GoString(tmp.pvshim_cmdline)
	x.PvshimExtra = C.GoString(tmp.pvshim_extra)
	return nil
}

func (x *DomainBuildInfo) toC() (xc C.libxl_domain_build_info, err error) {
	C.libxl_domain_build_info_init(&xc)
	xc.max_vcpus = C.int(x.MaxVcpus)
	xc.avail_vcpus, err = x.AvailVcpus.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.cpumap, err = x.Cpumap.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.nodemap, err = x.Nodemap.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	numVcpuHardAffinity := len(x.VcpuHardAffinity)
	xc.vcpu_hard_affinity = (*C.libxl_bitmap)(C.malloc(C.ulong(numVcpuHardAffinity) * C.sizeof_libxl_bitmap))
	xc.num_vcpu_hard_affinity = C.int(numVcpuHardAffinity)
	cVcpuHardAffinity := (*[1 << 28]C.libxl_bitmap)(unsafe.Pointer(xc.vcpu_hard_affinity))[:numVcpuHardAffinity:numVcpuHardAffinity]
	for i, v := range x.VcpuHardAffinity {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		cVcpuHardAffinity[i] = tmp
	}
	numVcpuSoftAffinity := len(x.VcpuSoftAffinity)
	xc.vcpu_soft_affinity = (*C.libxl_bitmap)(C.malloc(C.ulong(numVcpuSoftAffinity) * C.sizeof_libxl_bitmap))
	xc.num_vcpu_soft_affinity = C.int(numVcpuSoftAffinity)
	cVcpuSoftAffinity := (*[1 << 28]C.libxl_bitmap)(unsafe.Pointer(xc.vcpu_soft_affinity))[:numVcpuSoftAffinity:numVcpuSoftAffinity]
	for i, v := range x.VcpuSoftAffinity {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		cVcpuSoftAffinity[i] = tmp
	}
	xc.numa_placement, err = x.NumaPlacement.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.tsc_mode = C.libxl_tsc_mode(x.TscMode)
	xc.max_memkb = C.uint64_t(x.MaxMemkb)
	xc.target_memkb = C.uint64_t(x.TargetMemkb)
	xc.video_memkb = C.uint64_t(x.VideoMemkb)
	xc.shadow_memkb = C.uint64_t(x.ShadowMemkb)
	xc.iommu_memkb = C.uint64_t(x.IommuMemkb)
	xc.rtc_timeoffset = C.uint32_t(x.RtcTimeoffset)
	xc.exec_ssidref = C.uint32_t(x.ExecSsidref)
	xc.exec_ssid_label = C.CString(x.ExecSsidLabel)
	xc.localtime, err = x.Localtime.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.disable_migrate, err = x.DisableMigrate.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.cpuid, err = x.Cpuid.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.blkdev_start = C.CString(x.BlkdevStart)
	numVnumaNodes := len(x.VnumaNodes)
	xc.vnuma_nodes = (*C.libxl_vnode_info)(C.malloc(C.ulong(numVnumaNodes) * C.sizeof_libxl_vnode_info))
	xc.num_vnuma_nodes = C.int(numVnumaNodes)
	cVnumaNodes := (*[1 << 28]C.libxl_vnode_info)(unsafe.Pointer(xc.vnuma_nodes))[:numVnumaNodes:numVnumaNodes]
	for i, v := range x.VnumaNodes {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		cVnumaNodes[i] = tmp
	}
	xc.max_grant_frames = C.uint32_t(x.MaxGrantFrames)
	xc.max_maptrack_frames = C.uint32_t(x.MaxMaptrackFrames)
	xc.device_model_version = C.libxl_device_model_version(x.DeviceModelVersion)
	xc.device_model_stubdomain, err = x.DeviceModelStubdomain.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.device_model = C.CString(x.DeviceModel)
	xc.device_model_ssidref = C.uint32_t(x.DeviceModelSsidref)
	xc.device_model_ssid_label = C.CString(x.DeviceModelSsidLabel)
	xc.device_model_user = C.CString(x.DeviceModelUser)
	xc.extra, err = x.Extra.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.extra_pv, err = x.ExtraPv.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.extra_hvm, err = x.ExtraHvm.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.sched_params, err = x.SchedParams.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	numIoports := len(x.Ioports)
	xc.ioports = (*C.libxl_ioport_range)(C.malloc(C.ulong(numIoports) * C.sizeof_libxl_ioport_range))
	xc.num_ioports = C.int(numIoports)
	cIoports := (*[1 << 28]C.libxl_ioport_range)(unsafe.Pointer(xc.ioports))[:numIoports:numIoports]
	for i, v := range x.Ioports {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		cIoports[i] = tmp
	}
	numIrqs := len(x.Irqs)
	xc.irqs = (*C.uint32_t)(C.malloc(C.size_t(numIrqs * numIrqs)))
	xc.num_irqs = C.int(numIrqs)
	cIrqs := (*[1 << 28]C.uint32_t)(unsafe.Pointer(xc.irqs))[:numIrqs:numIrqs]
	for i, v := range x.Irqs {
		cIrqs[i] = C.uint32_t(v)
	}
	numIomem := len(x.Iomem)
	xc.iomem = (*C.libxl_iomem_range)(C.malloc(C.ulong(numIomem) * C.sizeof_libxl_iomem_range))
	xc.num_iomem = C.int(numIomem)
	cIomem := (*[1 << 28]C.libxl_iomem_range)(unsafe.Pointer(xc.iomem))[:numIomem:numIomem]
	for i, v := range x.Iomem {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		cIomem[i] = tmp
	}
	xc.claim_mode, err = x.ClaimMode.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.event_channels = C.uint32_t(x.EventChannels)
	xc.kernel = C.CString(x.Kernel)
	xc.cmdline = C.CString(x.Cmdline)
	xc.ramdisk = C.CString(x.Ramdisk)
	xc.device_tree = C.CString(x.DeviceTree)
	xc.acpi, err = x.Acpi.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.bootloader = C.CString(x.Bootloader)
	xc.bootloader_args, err = x.BootloaderArgs.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.timer_mode = C.libxl_timer_mode(x.TimerMode)
	xc.nested_hvm, err = x.NestedHvm.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.apic, err = x.Apic.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.dm_restrict, err = x.DmRestrict.toC()
	if err != nil {
		C.libxl_domain_build_info_dispose(&xc)
		return xc, err
	}
	xc.tee = C.libxl_tee_type(x.Tee)
	xc._type = C.libxl_domain_type(x.Type)
	switch x.Type {
	case DomainTypeHvm:
		tmp, ok := x.TypeUnion.(DomainBuildInfoTypeUnionHvm)
		if !ok {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, errors.New("wrong type for union key type")
		}
		var hvm C.libxl_domain_build_info_type_union_hvm
		hvm.firmware = C.CString(tmp.Firmware)
		hvm.bios = C.libxl_bios_type(tmp.Bios)
		hvm.pae, err = tmp.Pae.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.apic, err = tmp.Apic.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.acpi, err = tmp.Acpi.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.acpi_s3, err = tmp.AcpiS3.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.acpi_s4, err = tmp.AcpiS4.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.acpi_laptop_slate, err = tmp.AcpiLaptopSlate.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.nx, err = tmp.Nx.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.viridian, err = tmp.Viridian.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.viridian_enable, err = tmp.ViridianEnable.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.viridian_disable, err = tmp.ViridianDisable.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.timeoffset = C.CString(tmp.Timeoffset)
		hvm.hpet, err = tmp.Hpet.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.vpt_align, err = tmp.VptAlign.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.mmio_hole_memkb = C.uint64_t(tmp.MmioHoleMemkb)
		hvm.timer_mode = C.libxl_timer_mode(tmp.TimerMode)
		hvm.nested_hvm, err = tmp.NestedHvm.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.altp2m, err = tmp.Altp2M.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.system_firmware = C.CString(tmp.SystemFirmware)
		hvm.smbios_firmware = C.CString(tmp.SmbiosFirmware)
		hvm.acpi_firmware = C.CString(tmp.AcpiFirmware)
		hvm.hdtype = C.libxl_hdtype(tmp.Hdtype)
		hvm.nographic, err = tmp.Nographic.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.vga, err = tmp.Vga.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.vnc, err = tmp.Vnc.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.keymap = C.CString(tmp.Keymap)
		hvm.sdl, err = tmp.Sdl.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.spice, err = tmp.Spice.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.gfx_passthru, err = tmp.GfxPassthru.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.gfx_passthru_kind = C.libxl_gfx_passthru_kind(tmp.GfxPassthruKind)
		hvm.serial = C.CString(tmp.Serial)
		hvm.boot = C.CString(tmp.Boot)
		hvm.usb, err = tmp.Usb.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.usbversion = C.int(tmp.Usbversion)
		hvm.usbdevice = C.CString(tmp.Usbdevice)
		hvm.vkb_device, err = tmp.VkbDevice.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.soundhw = C.CString(tmp.Soundhw)
		hvm.xen_platform_pci, err = tmp.XenPlatformPci.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.usbdevice_list, err = tmp.UsbdeviceList.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.vendor_device = C.libxl_vendor_device(tmp.VendorDevice)
		hvm.ms_vm_genid, err = tmp.MsVmGenid.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.serial_list, err = tmp.SerialList.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.rdm, err = tmp.Rdm.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		hvm.rdm_mem_boundary_memkb = C.uint64_t(tmp.RdmMemBoundaryMemkb)
		hvm.mca_caps = C.uint64_t(tmp.McaCaps)
		hvmBytes := C.GoBytes(unsafe.Pointer(&hvm), C.sizeof_libxl_domain_build_info_type_union_hvm)
		copy(xc.u[:], hvmBytes)
	case DomainTypePv:
		tmp, ok := x.TypeUnion.(DomainBuildInfoTypeUnionPv)
		if !ok {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, errors.New("wrong type for union key type")
		}
		var pv C.libxl_domain_build_info_type_union_pv
		pv.kernel = C.CString(tmp.Kernel)
		pv.slack_memkb = C.uint64_t(tmp.SlackMemkb)
		pv.bootloader = C.CString(tmp.Bootloader)
		pv.bootloader_args, err = tmp.BootloaderArgs.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		pv.cmdline = C.CString(tmp.Cmdline)
		pv.ramdisk = C.CString(tmp.Ramdisk)
		pv.features = C.CString(tmp.Features)
		pv.e820_host, err = tmp.E820Host.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		pvBytes := C.GoBytes(unsafe.Pointer(&pv), C.sizeof_libxl_domain_build_info_type_union_pv)
		copy(xc.u[:], pvBytes)
	case DomainTypePvh:
		tmp, ok := x.TypeUnion.(DomainBuildInfoTypeUnionPvh)
		if !ok {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, errors.New("wrong type for union key type")
		}
		var pvh C.libxl_domain_build_info_type_union_pvh
		pvh.pvshim, err = tmp.Pvshim.toC()
		if err != nil {
			C.libxl_domain_build_info_dispose(&xc)
			return xc, err
		}
		pvh.pvshim_path = C.CString(tmp.PvshimPath)
		pvh.pvshim_cmdline = C.CString(tmp.PvshimCmdline)
		pvh.pvshim_extra = C.CString(tmp.PvshimExtra)
		pvhBytes := C.GoBytes(unsafe.Pointer(&pvh), C.sizeof_libxl_domain_build_info_type_union_pvh)
		copy(xc.u[:], pvhBytes)
	default:
		return xc, fmt.Errorf("invalid union key '%v'", x.Type)
	}
	xc.arch_arm.gic_version = C.libxl_gic_version(x.ArchArm.GicVersion)
	xc.arch_arm.vuart = C.libxl_vuart_type(x.ArchArm.Vuart)
	xc.altp2m = C.libxl_altp2m_mode(x.Altp2M)
	return xc, nil
}

func (x *DeviceVfb) fromC(xc *C.libxl_device_vfb) error {
	x.BackendDomid = Domid(xc.backend_domid)
	x.BackendDomname = C.GoString(xc.backend_domname)
	x.Devid = Devid(xc.devid)
	if err := x.Vnc.fromC(&xc.vnc); err != nil {
		return err
	}
	if err := x.Sdl.fromC(&xc.sdl); err != nil {
		return err
	}
	x.Keymap = C.GoString(xc.keymap)

	return nil
}

func (x *DeviceVfb) toC() (xc C.libxl_device_vfb, err error) {
	C.libxl_device_vfb_init(&xc)
	xc.backend_domid = C.libxl_domid(x.BackendDomid)
	xc.backend_domname = C.CString(x.BackendDomname)
	xc.devid = C.libxl_devid(x.Devid)
	xc.vnc, err = x.Vnc.toC()
	if err != nil {
		C.libxl_device_vfb_dispose(&xc)
		return xc, err
	}
	xc.sdl, err = x.Sdl.toC()
	if err != nil {
		C.libxl_device_vfb_dispose(&xc)
		return xc, err
	}
	xc.keymap = C.CString(x.Keymap)
	return xc, nil
}

func (x *DeviceVkb) fromC(xc *C.libxl_device_vkb) error {
	x.BackendDomid = Domid(xc.backend_domid)
	x.BackendDomname = C.GoString(xc.backend_domname)
	x.Devid = Devid(xc.devid)
	x.BackendType = VkbBackend(xc.backend_type)
	x.UniqueId = C.GoString(xc.unique_id)
	x.FeatureDisableKeyboard = bool(xc.feature_disable_keyboard)
	x.FeatureDisablePointer = bool(xc.feature_disable_pointer)
	x.FeatureAbsPointer = bool(xc.feature_abs_pointer)
	x.FeatureRawPointer = bool(xc.feature_raw_pointer)
	x.FeatureMultiTouch = bool(xc.feature_multi_touch)
	x.Width = uint32(xc.width)
	x.Height = uint32(xc.height)
	x.MultiTouchWidth = uint32(xc.multi_touch_width)
	x.MultiTouchHeight = uint32(xc.multi_touch_height)
	x.MultiTouchNumContacts = uint32(xc.multi_touch_num_contacts)

	return nil
}

func (x *DeviceVkb) toC() (xc C.libxl_device_vkb, err error) {
	C.libxl_device_vkb_init(&xc)
	xc.backend_domid = C.libxl_domid(x.BackendDomid)
	xc.backend_domname = C.CString(x.BackendDomname)
	xc.devid = C.libxl_devid(x.Devid)
	xc.backend_type = C.libxl_vkb_backend(x.BackendType)
	xc.unique_id = C.CString(x.UniqueId)
	xc.feature_disable_keyboard = C.bool(x.FeatureDisableKeyboard)
	xc.feature_disable_pointer = C.bool(x.FeatureDisablePointer)
	xc.feature_abs_pointer = C.bool(x.FeatureAbsPointer)
	xc.feature_raw_pointer = C.bool(x.FeatureRawPointer)
	xc.feature_multi_touch = C.bool(x.FeatureMultiTouch)
	xc.width = C.uint32_t(x.Width)
	xc.height = C.uint32_t(x.Height)
	xc.multi_touch_width = C.uint32_t(x.MultiTouchWidth)
	xc.multi_touch_height = C.uint32_t(x.MultiTouchHeight)
	xc.multi_touch_num_contacts = C.uint32_t(x.MultiTouchNumContacts)
	return xc, nil
}

func (x *DeviceDisk) fromC(xc *C.libxl_device_disk) error {
	x.BackendDomid = Domid(xc.backend_domid)
	x.BackendDomname = C.GoString(xc.backend_domname)
	x.PdevPath = C.GoString(xc.pdev_path)
	x.Vdev = C.GoString(xc.vdev)
	x.Backend = DiskBackend(xc.backend)
	x.Format = DiskFormat(xc.format)
	x.Script = C.GoString(xc.script)
	x.Removable = int(xc.removable)
	x.Readwrite = int(xc.readwrite)
	x.IsCdrom = int(xc.is_cdrom)
	x.DirectIoSafe = bool(xc.direct_io_safe)
	if err := x.DiscardEnable.fromC(&xc.discard_enable); err != nil {
		return err
	}
	if err := x.ColoEnable.fromC(&xc.colo_enable); err != nil {
		return err
	}
	if err := x.ColoRestoreEnable.fromC(&xc.colo_restore_enable); err != nil {
		return err
	}
	x.ColoHost = C.GoString(xc.colo_host)
	x.ColoPort = int(xc.colo_port)
	x.ColoExport = C.GoString(xc.colo_export)
	x.ActiveDisk = C.GoString(xc.active_disk)
	x.HiddenDisk = C.GoString(xc.hidden_disk)

	return nil
}

func (x *DeviceDisk) toC() (xc C.libxl_device_disk, err error) {
	C.libxl_device_disk_init(&xc)
	xc.backend_domid = C.libxl_domid(x.BackendDomid)
	xc.backend_domname = C.CString(x.BackendDomname)
	xc.pdev_path = C.CString(x.PdevPath)
	xc.vdev = C.CString(x.Vdev)
	xc.backend = C.libxl_disk_backend(x.Backend)
	xc.format = C.libxl_disk_format(x.Format)
	xc.script = C.CString(x.Script)
	xc.removable = C.int(x.Removable)
	xc.readwrite = C.int(x.Readwrite)
	xc.is_cdrom = C.int(x.IsCdrom)
	xc.direct_io_safe = C.bool(x.DirectIoSafe)
	xc.discard_enable, err = x.DiscardEnable.toC()
	if err != nil {
		C.libxl_device_disk_dispose(&xc)
		return xc, err
	}
	xc.colo_enable, err = x.ColoEnable.toC()
	if err != nil {
		C.libxl_device_disk_dispose(&xc)
		return xc, err
	}
	xc.colo_restore_enable, err = x.ColoRestoreEnable.toC()
	if err != nil {
		C.libxl_device_disk_dispose(&xc)
		return xc, err
	}
	xc.colo_host = C.CString(x.ColoHost)
	xc.colo_port = C.int(x.ColoPort)
	xc.colo_export = C.CString(x.ColoExport)
	xc.active_disk = C.CString(x.ActiveDisk)
	xc.hidden_disk = C.CString(x.HiddenDisk)
	return xc, nil
}

func (x *DeviceNic) fromC(xc *C.libxl_device_nic) error {
	x.BackendDomid = Domid(xc.backend_domid)
	x.BackendDomname = C.GoString(xc.backend_domname)
	x.Devid = Devid(xc.devid)
	x.Mtu = int(xc.mtu)
	x.Model = C.GoString(xc.model)
	if err := x.Mac.fromC(&xc.mac); err != nil {
		return err
	}
	x.Ip = C.GoString(xc.ip)
	x.Bridge = C.GoString(xc.bridge)
	x.Ifname = C.GoString(xc.ifname)
	x.Script = C.GoString(xc.script)
	x.Nictype = NicType(xc.nictype)
	x.RateBytesPerInterval = uint64(xc.rate_bytes_per_interval)
	x.RateIntervalUsecs = uint32(xc.rate_interval_usecs)
	x.Gatewaydev = C.GoString(xc.gatewaydev)
	x.ColoftForwarddev = C.GoString(xc.coloft_forwarddev)
	x.ColoSockMirrorId = C.GoString(xc.colo_sock_mirror_id)
	x.ColoSockMirrorIp = C.GoString(xc.colo_sock_mirror_ip)
	x.ColoSockMirrorPort = C.GoString(xc.colo_sock_mirror_port)
	x.ColoSockComparePriInId = C.GoString(xc.colo_sock_compare_pri_in_id)
	x.ColoSockComparePriInIp = C.GoString(xc.colo_sock_compare_pri_in_ip)
	x.ColoSockComparePriInPort = C.GoString(xc.colo_sock_compare_pri_in_port)
	x.ColoSockCompareSecInId = C.GoString(xc.colo_sock_compare_sec_in_id)
	x.ColoSockCompareSecInIp = C.GoString(xc.colo_sock_compare_sec_in_ip)
	x.ColoSockCompareSecInPort = C.GoString(xc.colo_sock_compare_sec_in_port)
	x.ColoSockCompareNotifyId = C.GoString(xc.colo_sock_compare_notify_id)
	x.ColoSockCompareNotifyIp = C.GoString(xc.colo_sock_compare_notify_ip)
	x.ColoSockCompareNotifyPort = C.GoString(xc.colo_sock_compare_notify_port)
	x.ColoSockRedirector0Id = C.GoString(xc.colo_sock_redirector0_id)
	x.ColoSockRedirector0Ip = C.GoString(xc.colo_sock_redirector0_ip)
	x.ColoSockRedirector0Port = C.GoString(xc.colo_sock_redirector0_port)
	x.ColoSockRedirector1Id = C.GoString(xc.colo_sock_redirector1_id)
	x.ColoSockRedirector1Ip = C.GoString(xc.colo_sock_redirector1_ip)
	x.ColoSockRedirector1Port = C.GoString(xc.colo_sock_redirector1_port)
	x.ColoSockRedirector2Id = C.GoString(xc.colo_sock_redirector2_id)
	x.ColoSockRedirector2Ip = C.GoString(xc.colo_sock_redirector2_ip)
	x.ColoSockRedirector2Port = C.GoString(xc.colo_sock_redirector2_port)
	x.ColoFilterMirrorQueue = C.GoString(xc.colo_filter_mirror_queue)
	x.ColoFilterMirrorOutdev = C.GoString(xc.colo_filter_mirror_outdev)
	x.ColoFilterRedirector0Queue = C.GoString(xc.colo_filter_redirector0_queue)
	x.ColoFilterRedirector0Indev = C.GoString(xc.colo_filter_redirector0_indev)
	x.ColoFilterRedirector0Outdev = C.GoString(xc.colo_filter_redirector0_outdev)
	x.ColoFilterRedirector1Queue = C.GoString(xc.colo_filter_redirector1_queue)
	x.ColoFilterRedirector1Indev = C.GoString(xc.colo_filter_redirector1_indev)
	x.ColoFilterRedirector1Outdev = C.GoString(xc.colo_filter_redirector1_outdev)
	x.ColoComparePriIn = C.GoString(xc.colo_compare_pri_in)
	x.ColoCompareSecIn = C.GoString(xc.colo_compare_sec_in)
	x.ColoCompareOut = C.GoString(xc.colo_compare_out)
	x.ColoCompareNotifyDev = C.GoString(xc.colo_compare_notify_dev)
	x.ColoSockSecRedirector0Id = C.GoString(xc.colo_sock_sec_redirector0_id)
	x.ColoSockSecRedirector0Ip = C.GoString(xc.colo_sock_sec_redirector0_ip)
	x.ColoSockSecRedirector0Port = C.GoString(xc.colo_sock_sec_redirector0_port)
	x.ColoSockSecRedirector1Id = C.GoString(xc.colo_sock_sec_redirector1_id)
	x.ColoSockSecRedirector1Ip = C.GoString(xc.colo_sock_sec_redirector1_ip)
	x.ColoSockSecRedirector1Port = C.GoString(xc.colo_sock_sec_redirector1_port)
	x.ColoFilterSecRedirector0Queue = C.GoString(xc.colo_filter_sec_redirector0_queue)
	x.ColoFilterSecRedirector0Indev = C.GoString(xc.colo_filter_sec_redirector0_indev)
	x.ColoFilterSecRedirector0Outdev = C.GoString(xc.colo_filter_sec_redirector0_outdev)
	x.ColoFilterSecRedirector1Queue = C.GoString(xc.colo_filter_sec_redirector1_queue)
	x.ColoFilterSecRedirector1Indev = C.GoString(xc.colo_filter_sec_redirector1_indev)
	x.ColoFilterSecRedirector1Outdev = C.GoString(xc.colo_filter_sec_redirector1_outdev)
	x.ColoFilterSecRewriter0Queue = C.GoString(xc.colo_filter_sec_rewriter0_queue)
	x.ColoCheckpointHost = C.GoString(xc.colo_checkpoint_host)
	x.ColoCheckpointPort = C.GoString(xc.colo_checkpoint_port)

	return nil
}

func (x *DeviceNic) toC() (xc C.libxl_device_nic, err error) {
	C.libxl_device_nic_init(&xc)
	xc.backend_domid = C.libxl_domid(x.BackendDomid)
	xc.backend_domname = C.CString(x.BackendDomname)
	xc.devid = C.libxl_devid(x.Devid)
	xc.mtu = C.int(x.Mtu)
	xc.model = C.CString(x.Model)
	xc.mac, err = x.Mac.toC()
	if err != nil {
		C.libxl_device_nic_dispose(&xc)
		return xc, err
	}
	xc.ip = C.CString(x.Ip)
	xc.bridge = C.CString(x.Bridge)
	xc.ifname = C.CString(x.Ifname)
	xc.script = C.CString(x.Script)
	xc.nictype = C.libxl_nic_type(x.Nictype)
	xc.rate_bytes_per_interval = C.uint64_t(x.RateBytesPerInterval)
	xc.rate_interval_usecs = C.uint32_t(x.RateIntervalUsecs)
	xc.gatewaydev = C.CString(x.Gatewaydev)
	xc.coloft_forwarddev = C.CString(x.ColoftForwarddev)
	xc.colo_sock_mirror_id = C.CString(x.ColoSockMirrorId)
	xc.colo_sock_mirror_ip = C.CString(x.ColoSockMirrorIp)
	xc.colo_sock_mirror_port = C.CString(x.ColoSockMirrorPort)
	xc.colo_sock_compare_pri_in_id = C.CString(x.ColoSockComparePriInId)
	xc.colo_sock_compare_pri_in_ip = C.CString(x.ColoSockComparePriInIp)
	xc.colo_sock_compare_pri_in_port = C.CString(x.ColoSockComparePriInPort)
	xc.colo_sock_compare_sec_in_id = C.CString(x.ColoSockCompareSecInId)
	xc.colo_sock_compare_sec_in_ip = C.CString(x.ColoSockCompareSecInIp)
	xc.colo_sock_compare_sec_in_port = C.CString(x.ColoSockCompareSecInPort)
	xc.colo_sock_compare_notify_id = C.CString(x.ColoSockCompareNotifyId)
	xc.colo_sock_compare_notify_ip = C.CString(x.ColoSockCompareNotifyIp)
	xc.colo_sock_compare_notify_port = C.CString(x.ColoSockCompareNotifyPort)
	xc.colo_sock_redirector0_id = C.CString(x.ColoSockRedirector0Id)
	xc.colo_sock_redirector0_ip = C.CString(x.ColoSockRedirector0Ip)
	xc.colo_sock_redirector0_port = C.CString(x.ColoSockRedirector0Port)
	xc.colo_sock_redirector1_id = C.CString(x.ColoSockRedirector1Id)
	xc.colo_sock_redirector1_ip = C.CString(x.ColoSockRedirector1Ip)
	xc.colo_sock_redirector1_port = C.CString(x.ColoSockRedirector1Port)
	xc.colo_sock_redirector2_id = C.CString(x.ColoSockRedirector2Id)
	xc.colo_sock_redirector2_ip = C.CString(x.ColoSockRedirector2Ip)
	xc.colo_sock_redirector2_port = C.CString(x.ColoSockRedirector2Port)
	xc.colo_filter_mirror_queue = C.CString(x.ColoFilterMirrorQueue)
	xc.colo_filter_mirror_outdev = C.CString(x.ColoFilterMirrorOutdev)
	xc.colo_filter_redirector0_queue = C.CString(x.ColoFilterRedirector0Queue)
	xc.colo_filter_redirector0_indev = C.CString(x.ColoFilterRedirector0Indev)
	xc.colo_filter_redirector0_outdev = C.CString(x.ColoFilterRedirector0Outdev)
	xc.colo_filter_redirector1_queue = C.CString(x.ColoFilterRedirector1Queue)
	xc.colo_filter_redirector1_indev = C.CString(x.ColoFilterRedirector1Indev)
	xc.colo_filter_redirector1_outdev = C.CString(x.ColoFilterRedirector1Outdev)
	xc.colo_compare_pri_in = C.CString(x.ColoComparePriIn)
	xc.colo_compare_sec_in = C.CString(x.ColoCompareSecIn)
	xc.colo_compare_out = C.CString(x.ColoCompareOut)
	xc.colo_compare_notify_dev = C.CString(x.ColoCompareNotifyDev)
	xc.colo_sock_sec_redirector0_id = C.CString(x.ColoSockSecRedirector0Id)
	xc.colo_sock_sec_redirector0_ip = C.CString(x.ColoSockSecRedirector0Ip)
	xc.colo_sock_sec_redirector0_port = C.CString(x.ColoSockSecRedirector0Port)
	xc.colo_sock_sec_redirector1_id = C.CString(x.ColoSockSecRedirector1Id)
	xc.colo_sock_sec_redirector1_ip = C.CString(x.ColoSockSecRedirector1Ip)
	xc.colo_sock_sec_redirector1_port = C.CString(x.ColoSockSecRedirector1Port)
	xc.colo_filter_sec_redirector0_queue = C.CString(x.ColoFilterSecRedirector0Queue)
	xc.colo_filter_sec_redirector0_indev = C.CString(x.ColoFilterSecRedirector0Indev)
	xc.colo_filter_sec_redirector0_outdev = C.CString(x.ColoFilterSecRedirector0Outdev)
	xc.colo_filter_sec_redirector1_queue = C.CString(x.ColoFilterSecRedirector1Queue)
	xc.colo_filter_sec_redirector1_indev = C.CString(x.ColoFilterSecRedirector1Indev)
	xc.colo_filter_sec_redirector1_outdev = C.CString(x.ColoFilterSecRedirector1Outdev)
	xc.colo_filter_sec_rewriter0_queue = C.CString(x.ColoFilterSecRewriter0Queue)
	xc.colo_checkpoint_host = C.CString(x.ColoCheckpointHost)
	xc.colo_checkpoint_port = C.CString(x.ColoCheckpointPort)
	return xc, nil
}

func (x *DevicePci) fromC(xc *C.libxl_device_pci) error {
	x.Func = byte(xc._func)
	x.Dev = byte(xc.dev)
	x.Bus = byte(xc.bus)
	x.Domain = int(xc.domain)
	x.Vdevfn = uint32(xc.vdevfn)
	x.VfuncMask = uint32(xc.vfunc_mask)
	x.Msitranslate = bool(xc.msitranslate)
	x.PowerMgmt = bool(xc.power_mgmt)
	x.Permissive = bool(xc.permissive)
	x.Seize = bool(xc.seize)
	x.RdmPolicy = RdmReservePolicy(xc.rdm_policy)

	return nil
}

func (x *DevicePci) toC() (xc C.libxl_device_pci, err error) {
	C.libxl_device_pci_init(&xc)
	xc._func = C.uint8_t(x.Func)
	xc.dev = C.uint8_t(x.Dev)
	xc.bus = C.uint8_t(x.Bus)
	xc.domain = C.int(x.Domain)
	xc.vdevfn = C.uint32_t(x.Vdevfn)
	xc.vfunc_mask = C.uint32_t(x.VfuncMask)
	xc.msitranslate = C.bool(x.Msitranslate)
	xc.power_mgmt = C.bool(x.PowerMgmt)
	xc.permissive = C.bool(x.Permissive)
	xc.seize = C.bool(x.Seize)
	xc.rdm_policy = C.libxl_rdm_reserve_policy(x.RdmPolicy)
	return xc, nil
}

func (x *DeviceRdm) fromC(xc *C.libxl_device_rdm) error {
	x.Start = uint64(xc.start)
	x.Size = uint64(xc.size)
	x.Policy = RdmReservePolicy(xc.policy)

	return nil
}

func (x *DeviceRdm) toC() (xc C.libxl_device_rdm, err error) {
	C.libxl_device_rdm_init(&xc)
	xc.start = C.uint64_t(x.Start)
	xc.size = C.uint64_t(x.Size)
	xc.policy = C.libxl_rdm_reserve_policy(x.Policy)
	return xc, nil
}

func (x *DeviceUsbctrl) fromC(xc *C.libxl_device_usbctrl) error {
	x.Type = UsbctrlType(xc._type)
	x.Devid = Devid(xc.devid)
	x.Version = int(xc.version)
	x.Ports = int(xc.ports)
	x.BackendDomid = Domid(xc.backend_domid)
	x.BackendDomname = C.GoString(xc.backend_domname)

	return nil
}

func (x *DeviceUsbctrl) toC() (xc C.libxl_device_usbctrl, err error) {
	C.libxl_device_usbctrl_init(&xc)
	xc._type = C.libxl_usbctrl_type(x.Type)
	xc.devid = C.libxl_devid(x.Devid)
	xc.version = C.int(x.Version)
	xc.ports = C.int(x.Ports)
	xc.backend_domid = C.libxl_domid(x.BackendDomid)
	xc.backend_domname = C.CString(x.BackendDomname)
	return xc, nil
}

func (x *DeviceUsbdev) fromC(xc *C.libxl_device_usbdev) error {
	x.Ctrl = Devid(xc.ctrl)
	x.Port = int(xc.port)
	x.Type = UsbdevType(xc._type)
	switch x.Type {
	case UsbdevTypeHostdev:
		var typeHostdev DeviceUsbdevTypeUnionHostdev
		if err := typeHostdev.fromC(xc); err != nil {
			return err
		}
		x.TypeUnion = typeHostdev
	default:
		return fmt.Errorf("invalid union key '%v'", x.Type)
	}

	return nil
}

func (x *DeviceUsbdevTypeUnionHostdev) fromC(xc *C.libxl_device_usbdev) error {
	if UsbdevType(xc._type) != UsbdevTypeHostdev {
		return errors.New("expected union key UsbdevTypeHostdev")
	}

	tmp := (*C.libxl_device_usbdev_type_union_hostdev)(unsafe.Pointer(&xc.u[0]))
	x.Hostbus = byte(tmp.hostbus)
	x.Hostaddr = byte(tmp.hostaddr)
	return nil
}

func (x *DeviceUsbdev) toC() (xc C.libxl_device_usbdev, err error) {
	C.libxl_device_usbdev_init(&xc)
	xc.ctrl = C.libxl_devid(x.Ctrl)
	xc.port = C.int(x.Port)
	xc._type = C.libxl_usbdev_type(x.Type)
	switch x.Type {
	case UsbdevTypeHostdev:
		tmp, ok := x.TypeUnion.(DeviceUsbdevTypeUnionHostdev)
		if !ok {
			C.libxl_device_usbdev_dispose(&xc)
			return xc, errors.New("wrong type for union key type")
		}
		var hostdev C.libxl_device_usbdev_type_union_hostdev
		hostdev.hostbus = C.uint8_t(tmp.Hostbus)
		hostdev.hostaddr = C.uint8_t(tmp.Hostaddr)
		hostdevBytes := C.GoBytes(unsafe.Pointer(&hostdev), C.sizeof_libxl_device_usbdev_type_union_hostdev)
		copy(xc.u[:], hostdevBytes)
	default:
		return xc, fmt.Errorf("invalid union key '%v'", x.Type)
	}
	return xc, nil
}

func (x *DeviceDtdev) fromC(xc *C.libxl_device_dtdev) error {
	x.Path = C.GoString(xc.path)

	return nil
}

func (x *DeviceDtdev) toC() (xc C.libxl_device_dtdev, err error) {
	C.libxl_device_dtdev_init(&xc)
	xc.path = C.CString(x.Path)
	return xc, nil
}

func (x *DeviceVtpm) fromC(xc *C.libxl_device_vtpm) error {
	x.BackendDomid = Domid(xc.backend_domid)
	x.BackendDomname = C.GoString(xc.backend_domname)
	x.Devid = Devid(xc.devid)
	if err := x.Uuid.fromC(&xc.uuid); err != nil {
		return err
	}

	return nil
}

func (x *DeviceVtpm) toC() (xc C.libxl_device_vtpm, err error) {
	C.libxl_device_vtpm_init(&xc)
	xc.backend_domid = C.libxl_domid(x.BackendDomid)
	xc.backend_domname = C.CString(x.BackendDomname)
	xc.devid = C.libxl_devid(x.Devid)
	xc.uuid, err = x.Uuid.toC()
	if err != nil {
		C.libxl_device_vtpm_dispose(&xc)
		return xc, err
	}
	return xc, nil
}

func (x *DeviceP9) fromC(xc *C.libxl_device_p9) error {
	x.BackendDomid = Domid(xc.backend_domid)
	x.BackendDomname = C.GoString(xc.backend_domname)
	x.Tag = C.GoString(xc.tag)
	x.Path = C.GoString(xc.path)
	x.SecurityModel = C.GoString(xc.security_model)
	x.Devid = Devid(xc.devid)

	return nil
}

func (x *DeviceP9) toC() (xc C.libxl_device_p9, err error) {
	C.libxl_device_p9_init(&xc)
	xc.backend_domid = C.libxl_domid(x.BackendDomid)
	xc.backend_domname = C.CString(x.BackendDomname)
	xc.tag = C.CString(x.Tag)
	xc.path = C.CString(x.Path)
	xc.security_model = C.CString(x.SecurityModel)
	xc.devid = C.libxl_devid(x.Devid)
	return xc, nil
}

func (x *DevicePvcallsif) fromC(xc *C.libxl_device_pvcallsif) error {
	x.BackendDomid = Domid(xc.backend_domid)
	x.BackendDomname = C.GoString(xc.backend_domname)
	x.Devid = Devid(xc.devid)

	return nil
}

func (x *DevicePvcallsif) toC() (xc C.libxl_device_pvcallsif, err error) {
	C.libxl_device_pvcallsif_init(&xc)
	xc.backend_domid = C.libxl_domid(x.BackendDomid)
	xc.backend_domname = C.CString(x.BackendDomname)
	xc.devid = C.libxl_devid(x.Devid)
	return xc, nil
}

func (x *DeviceChannel) fromC(xc *C.libxl_device_channel) error {
	x.BackendDomid = Domid(xc.backend_domid)
	x.BackendDomname = C.GoString(xc.backend_domname)
	x.Devid = Devid(xc.devid)
	x.Name = C.GoString(xc.name)
	x.Connection = ChannelConnection(xc.connection)
	switch x.Connection {
	case ChannelConnectionSocket:
		var connectionSocket DeviceChannelConnectionUnionSocket
		if err := connectionSocket.fromC(xc); err != nil {
			return err
		}
		x.ConnectionUnion = connectionSocket
	default:
		return fmt.Errorf("invalid union key '%v'", x.Connection)
	}

	return nil
}

func (x *DeviceChannelConnectionUnionSocket) fromC(xc *C.libxl_device_channel) error {
	if ChannelConnection(xc.connection) != ChannelConnectionSocket {
		return errors.New("expected union key ChannelConnectionSocket")
	}

	tmp := (*C.libxl_device_channel_connection_union_socket)(unsafe.Pointer(&xc.u[0]))
	x.Path = C.GoString(tmp.path)
	return nil
}

func (x *DeviceChannel) toC() (xc C.libxl_device_channel, err error) {
	C.libxl_device_channel_init(&xc)
	xc.backend_domid = C.libxl_domid(x.BackendDomid)
	xc.backend_domname = C.CString(x.BackendDomname)
	xc.devid = C.libxl_devid(x.Devid)
	xc.name = C.CString(x.Name)
	xc.connection = C.libxl_channel_connection(x.Connection)
	switch x.Connection {
	case ChannelConnectionSocket:
		tmp, ok := x.ConnectionUnion.(DeviceChannelConnectionUnionSocket)
		if !ok {
			C.libxl_device_channel_dispose(&xc)
			return xc, errors.New("wrong type for union key connection")
		}
		var socket C.libxl_device_channel_connection_union_socket
		socket.path = C.CString(tmp.Path)
		socketBytes := C.GoBytes(unsafe.Pointer(&socket), C.sizeof_libxl_device_channel_connection_union_socket)
		copy(xc.u[:], socketBytes)
	default:
		return xc, fmt.Errorf("invalid union key '%v'", x.Connection)
	}
	return xc, nil
}

func (x *ConnectorParam) fromC(xc *C.libxl_connector_param) error {
	x.UniqueId = C.GoString(xc.unique_id)
	x.Width = uint32(xc.width)
	x.Height = uint32(xc.height)

	return nil
}

func (x *ConnectorParam) toC() (xc C.libxl_connector_param, err error) {
	C.libxl_connector_param_init(&xc)
	xc.unique_id = C.CString(x.UniqueId)
	xc.width = C.uint32_t(x.Width)
	xc.height = C.uint32_t(x.Height)
	return xc, nil
}

func (x *DeviceVdispl) fromC(xc *C.libxl_device_vdispl) error {
	x.BackendDomid = Domid(xc.backend_domid)
	x.BackendDomname = C.GoString(xc.backend_domname)
	x.Devid = Devid(xc.devid)
	x.BeAlloc = bool(xc.be_alloc)
	numConnectors := int(xc.num_connectors)
	cConnectors := (*[1 << 28]C.libxl_connector_param)(unsafe.Pointer(xc.connectors))[:numConnectors:numConnectors]
	x.Connectors = make([]ConnectorParam, numConnectors)
	for i, v := range cConnectors {
		var e ConnectorParam
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Connectors[i] = e
	}

	return nil
}

func (x *DeviceVdispl) toC() (xc C.libxl_device_vdispl, err error) {
	C.libxl_device_vdispl_init(&xc)
	xc.backend_domid = C.libxl_domid(x.BackendDomid)
	xc.backend_domname = C.CString(x.BackendDomname)
	xc.devid = C.libxl_devid(x.Devid)
	xc.be_alloc = C.bool(x.BeAlloc)
	numConnectors := len(x.Connectors)
	xc.connectors = (*C.libxl_connector_param)(C.malloc(C.ulong(numConnectors) * C.sizeof_libxl_connector_param))
	xc.num_connectors = C.int(numConnectors)
	cConnectors := (*[1 << 28]C.libxl_connector_param)(unsafe.Pointer(xc.connectors))[:numConnectors:numConnectors]
	for i, v := range x.Connectors {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_device_vdispl_dispose(&xc)
			return xc, err
		}
		cConnectors[i] = tmp
	}
	return xc, nil
}

func (x *VsndParams) fromC(xc *C.libxl_vsnd_params) error {
	numSampleRates := int(xc.num_sample_rates)
	cSampleRates := (*[1 << 28]C.uint32_t)(unsafe.Pointer(xc.sample_rates))[:numSampleRates:numSampleRates]
	x.SampleRates = make([]uint32, numSampleRates)
	for i, v := range cSampleRates {
		x.SampleRates[i] = uint32(v)
	}
	numSampleFormats := int(xc.num_sample_formats)
	cSampleFormats := (*[1 << 28]C.libxl_vsnd_pcm_format)(unsafe.Pointer(xc.sample_formats))[:numSampleFormats:numSampleFormats]
	x.SampleFormats = make([]VsndPcmFormat, numSampleFormats)
	for i, v := range cSampleFormats {
		x.SampleFormats[i] = VsndPcmFormat(v)
	}
	x.ChannelsMin = uint32(xc.channels_min)
	x.ChannelsMax = uint32(xc.channels_max)
	x.BufferSize = uint32(xc.buffer_size)

	return nil
}

func (x *VsndParams) toC() (xc C.libxl_vsnd_params, err error) {
	C.libxl_vsnd_params_init(&xc)
	numSampleRates := len(x.SampleRates)
	xc.sample_rates = (*C.uint32_t)(C.malloc(C.size_t(numSampleRates * numSampleRates)))
	xc.num_sample_rates = C.int(numSampleRates)
	cSampleRates := (*[1 << 28]C.uint32_t)(unsafe.Pointer(xc.sample_rates))[:numSampleRates:numSampleRates]
	for i, v := range x.SampleRates {
		cSampleRates[i] = C.uint32_t(v)
	}
	numSampleFormats := len(x.SampleFormats)
	xc.sample_formats = (*C.libxl_vsnd_pcm_format)(C.malloc(C.size_t(numSampleFormats * numSampleFormats)))
	xc.num_sample_formats = C.int(numSampleFormats)
	cSampleFormats := (*[1 << 28]C.libxl_vsnd_pcm_format)(unsafe.Pointer(xc.sample_formats))[:numSampleFormats:numSampleFormats]
	for i, v := range x.SampleFormats {
		cSampleFormats[i] = C.libxl_vsnd_pcm_format(v)
	}
	xc.channels_min = C.uint32_t(x.ChannelsMin)
	xc.channels_max = C.uint32_t(x.ChannelsMax)
	xc.buffer_size = C.uint32_t(x.BufferSize)
	return xc, nil
}

func (x *VsndStream) fromC(xc *C.libxl_vsnd_stream) error {
	x.UniqueId = C.GoString(xc.unique_id)
	x.Type = VsndStreamType(xc._type)
	if err := x.Params.fromC(&xc.params); err != nil {
		return err
	}

	return nil
}

func (x *VsndStream) toC() (xc C.libxl_vsnd_stream, err error) {
	C.libxl_vsnd_stream_init(&xc)
	xc.unique_id = C.CString(x.UniqueId)
	xc._type = C.libxl_vsnd_stream_type(x.Type)
	xc.params, err = x.Params.toC()
	if err != nil {
		C.libxl_vsnd_stream_dispose(&xc)
		return xc, err
	}
	return xc, nil
}

func (x *VsndPcm) fromC(xc *C.libxl_vsnd_pcm) error {
	x.Name = C.GoString(xc.name)
	if err := x.Params.fromC(&xc.params); err != nil {
		return err
	}
	numVsndStreams := int(xc.num_vsnd_streams)
	cStreams := (*[1 << 28]C.libxl_vsnd_stream)(unsafe.Pointer(xc.streams))[:numVsndStreams:numVsndStreams]
	x.Streams = make([]VsndStream, numVsndStreams)
	for i, v := range cStreams {
		var e VsndStream
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Streams[i] = e
	}

	return nil
}

func (x *VsndPcm) toC() (xc C.libxl_vsnd_pcm, err error) {
	C.libxl_vsnd_pcm_init(&xc)
	xc.name = C.CString(x.Name)
	xc.params, err = x.Params.toC()
	if err != nil {
		C.libxl_vsnd_pcm_dispose(&xc)
		return xc, err
	}
	numVsndStreams := len(x.Streams)
	xc.streams = (*C.libxl_vsnd_stream)(C.malloc(C.ulong(numVsndStreams) * C.sizeof_libxl_vsnd_stream))
	xc.num_vsnd_streams = C.int(numVsndStreams)
	cStreams := (*[1 << 28]C.libxl_vsnd_stream)(unsafe.Pointer(xc.streams))[:numVsndStreams:numVsndStreams]
	for i, v := range x.Streams {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_vsnd_pcm_dispose(&xc)
			return xc, err
		}
		cStreams[i] = tmp
	}
	return xc, nil
}

func (x *DeviceVsnd) fromC(xc *C.libxl_device_vsnd) error {
	x.BackendDomid = Domid(xc.backend_domid)
	x.BackendDomname = C.GoString(xc.backend_domname)
	x.Devid = Devid(xc.devid)
	x.ShortName = C.GoString(xc.short_name)
	x.LongName = C.GoString(xc.long_name)
	if err := x.Params.fromC(&xc.params); err != nil {
		return err
	}
	numVsndPcms := int(xc.num_vsnd_pcms)
	cPcms := (*[1 << 28]C.libxl_vsnd_pcm)(unsafe.Pointer(xc.pcms))[:numVsndPcms:numVsndPcms]
	x.Pcms = make([]VsndPcm, numVsndPcms)
	for i, v := range cPcms {
		var e VsndPcm
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Pcms[i] = e
	}

	return nil
}

func (x *DeviceVsnd) toC() (xc C.libxl_device_vsnd, err error) {
	C.libxl_device_vsnd_init(&xc)
	xc.backend_domid = C.libxl_domid(x.BackendDomid)
	xc.backend_domname = C.CString(x.BackendDomname)
	xc.devid = C.libxl_devid(x.Devid)
	xc.short_name = C.CString(x.ShortName)
	xc.long_name = C.CString(x.LongName)
	xc.params, err = x.Params.toC()
	if err != nil {
		C.libxl_device_vsnd_dispose(&xc)
		return xc, err
	}
	numVsndPcms := len(x.Pcms)
	xc.pcms = (*C.libxl_vsnd_pcm)(C.malloc(C.ulong(numVsndPcms) * C.sizeof_libxl_vsnd_pcm))
	xc.num_vsnd_pcms = C.int(numVsndPcms)
	cPcms := (*[1 << 28]C.libxl_vsnd_pcm)(unsafe.Pointer(xc.pcms))[:numVsndPcms:numVsndPcms]
	for i, v := range x.Pcms {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_device_vsnd_dispose(&xc)
			return xc, err
		}
		cPcms[i] = tmp
	}
	return xc, nil
}

func (x *DomainConfig) fromC(xc *C.libxl_domain_config) error {
	if err := x.CInfo.fromC(&xc.c_info); err != nil {
		return err
	}
	if err := x.BInfo.fromC(&xc.b_info); err != nil {
		return err
	}
	numDisks := int(xc.num_disks)
	cDisks := (*[1 << 28]C.libxl_device_disk)(unsafe.Pointer(xc.disks))[:numDisks:numDisks]
	x.Disks = make([]DeviceDisk, numDisks)
	for i, v := range cDisks {
		var e DeviceDisk
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Disks[i] = e
	}
	numNics := int(xc.num_nics)
	cNics := (*[1 << 28]C.libxl_device_nic)(unsafe.Pointer(xc.nics))[:numNics:numNics]
	x.Nics = make([]DeviceNic, numNics)
	for i, v := range cNics {
		var e DeviceNic
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Nics[i] = e
	}
	numPcidevs := int(xc.num_pcidevs)
	cPcidevs := (*[1 << 28]C.libxl_device_pci)(unsafe.Pointer(xc.pcidevs))[:numPcidevs:numPcidevs]
	x.Pcidevs = make([]DevicePci, numPcidevs)
	for i, v := range cPcidevs {
		var e DevicePci
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Pcidevs[i] = e
	}
	numRdms := int(xc.num_rdms)
	cRdms := (*[1 << 28]C.libxl_device_rdm)(unsafe.Pointer(xc.rdms))[:numRdms:numRdms]
	x.Rdms = make([]DeviceRdm, numRdms)
	for i, v := range cRdms {
		var e DeviceRdm
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Rdms[i] = e
	}
	numDtdevs := int(xc.num_dtdevs)
	cDtdevs := (*[1 << 28]C.libxl_device_dtdev)(unsafe.Pointer(xc.dtdevs))[:numDtdevs:numDtdevs]
	x.Dtdevs = make([]DeviceDtdev, numDtdevs)
	for i, v := range cDtdevs {
		var e DeviceDtdev
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Dtdevs[i] = e
	}
	numVfbs := int(xc.num_vfbs)
	cVfbs := (*[1 << 28]C.libxl_device_vfb)(unsafe.Pointer(xc.vfbs))[:numVfbs:numVfbs]
	x.Vfbs = make([]DeviceVfb, numVfbs)
	for i, v := range cVfbs {
		var e DeviceVfb
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Vfbs[i] = e
	}
	numVkbs := int(xc.num_vkbs)
	cVkbs := (*[1 << 28]C.libxl_device_vkb)(unsafe.Pointer(xc.vkbs))[:numVkbs:numVkbs]
	x.Vkbs = make([]DeviceVkb, numVkbs)
	for i, v := range cVkbs {
		var e DeviceVkb
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Vkbs[i] = e
	}
	numVtpms := int(xc.num_vtpms)
	cVtpms := (*[1 << 28]C.libxl_device_vtpm)(unsafe.Pointer(xc.vtpms))[:numVtpms:numVtpms]
	x.Vtpms = make([]DeviceVtpm, numVtpms)
	for i, v := range cVtpms {
		var e DeviceVtpm
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Vtpms[i] = e
	}
	numP9S := int(xc.num_p9s)
	cP9S := (*[1 << 28]C.libxl_device_p9)(unsafe.Pointer(xc.p9s))[:numP9S:numP9S]
	x.P9S = make([]DeviceP9, numP9S)
	for i, v := range cP9S {
		var e DeviceP9
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.P9S[i] = e
	}
	numPvcallsifs := int(xc.num_pvcallsifs)
	cPvcallsifs := (*[1 << 28]C.libxl_device_pvcallsif)(unsafe.Pointer(xc.pvcallsifs))[:numPvcallsifs:numPvcallsifs]
	x.Pvcallsifs = make([]DevicePvcallsif, numPvcallsifs)
	for i, v := range cPvcallsifs {
		var e DevicePvcallsif
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Pvcallsifs[i] = e
	}
	numVdispls := int(xc.num_vdispls)
	cVdispls := (*[1 << 28]C.libxl_device_vdispl)(unsafe.Pointer(xc.vdispls))[:numVdispls:numVdispls]
	x.Vdispls = make([]DeviceVdispl, numVdispls)
	for i, v := range cVdispls {
		var e DeviceVdispl
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Vdispls[i] = e
	}
	numVsnds := int(xc.num_vsnds)
	cVsnds := (*[1 << 28]C.libxl_device_vsnd)(unsafe.Pointer(xc.vsnds))[:numVsnds:numVsnds]
	x.Vsnds = make([]DeviceVsnd, numVsnds)
	for i, v := range cVsnds {
		var e DeviceVsnd
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Vsnds[i] = e
	}
	numChannels := int(xc.num_channels)
	cChannels := (*[1 << 28]C.libxl_device_channel)(unsafe.Pointer(xc.channels))[:numChannels:numChannels]
	x.Channels = make([]DeviceChannel, numChannels)
	for i, v := range cChannels {
		var e DeviceChannel
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Channels[i] = e
	}
	numUsbctrls := int(xc.num_usbctrls)
	cUsbctrls := (*[1 << 28]C.libxl_device_usbctrl)(unsafe.Pointer(xc.usbctrls))[:numUsbctrls:numUsbctrls]
	x.Usbctrls = make([]DeviceUsbctrl, numUsbctrls)
	for i, v := range cUsbctrls {
		var e DeviceUsbctrl
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Usbctrls[i] = e
	}
	numUsbdevs := int(xc.num_usbdevs)
	cUsbdevs := (*[1 << 28]C.libxl_device_usbdev)(unsafe.Pointer(xc.usbdevs))[:numUsbdevs:numUsbdevs]
	x.Usbdevs = make([]DeviceUsbdev, numUsbdevs)
	for i, v := range cUsbdevs {
		var e DeviceUsbdev
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Usbdevs[i] = e
	}
	x.OnPoweroff = ActionOnShutdown(xc.on_poweroff)
	x.OnReboot = ActionOnShutdown(xc.on_reboot)
	x.OnWatchdog = ActionOnShutdown(xc.on_watchdog)
	x.OnCrash = ActionOnShutdown(xc.on_crash)
	x.OnSoftReset = ActionOnShutdown(xc.on_soft_reset)

	return nil
}

func (x *DomainConfig) toC() (xc C.libxl_domain_config, err error) {
	C.libxl_domain_config_init(&xc)
	xc.c_info, err = x.CInfo.toC()
	if err != nil {
		C.libxl_domain_config_dispose(&xc)
		return xc, err
	}
	xc.b_info, err = x.BInfo.toC()
	if err != nil {
		C.libxl_domain_config_dispose(&xc)
		return xc, err
	}
	numDisks := len(x.Disks)
	xc.disks = (*C.libxl_device_disk)(C.malloc(C.ulong(numDisks) * C.sizeof_libxl_device_disk))
	xc.num_disks = C.int(numDisks)
	cDisks := (*[1 << 28]C.libxl_device_disk)(unsafe.Pointer(xc.disks))[:numDisks:numDisks]
	for i, v := range x.Disks {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cDisks[i] = tmp
	}
	numNics := len(x.Nics)
	xc.nics = (*C.libxl_device_nic)(C.malloc(C.ulong(numNics) * C.sizeof_libxl_device_nic))
	xc.num_nics = C.int(numNics)
	cNics := (*[1 << 28]C.libxl_device_nic)(unsafe.Pointer(xc.nics))[:numNics:numNics]
	for i, v := range x.Nics {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cNics[i] = tmp
	}
	numPcidevs := len(x.Pcidevs)
	xc.pcidevs = (*C.libxl_device_pci)(C.malloc(C.ulong(numPcidevs) * C.sizeof_libxl_device_pci))
	xc.num_pcidevs = C.int(numPcidevs)
	cPcidevs := (*[1 << 28]C.libxl_device_pci)(unsafe.Pointer(xc.pcidevs))[:numPcidevs:numPcidevs]
	for i, v := range x.Pcidevs {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cPcidevs[i] = tmp
	}
	numRdms := len(x.Rdms)
	xc.rdms = (*C.libxl_device_rdm)(C.malloc(C.ulong(numRdms) * C.sizeof_libxl_device_rdm))
	xc.num_rdms = C.int(numRdms)
	cRdms := (*[1 << 28]C.libxl_device_rdm)(unsafe.Pointer(xc.rdms))[:numRdms:numRdms]
	for i, v := range x.Rdms {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cRdms[i] = tmp
	}
	numDtdevs := len(x.Dtdevs)
	xc.dtdevs = (*C.libxl_device_dtdev)(C.malloc(C.ulong(numDtdevs) * C.sizeof_libxl_device_dtdev))
	xc.num_dtdevs = C.int(numDtdevs)
	cDtdevs := (*[1 << 28]C.libxl_device_dtdev)(unsafe.Pointer(xc.dtdevs))[:numDtdevs:numDtdevs]
	for i, v := range x.Dtdevs {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cDtdevs[i] = tmp
	}
	numVfbs := len(x.Vfbs)
	xc.vfbs = (*C.libxl_device_vfb)(C.malloc(C.ulong(numVfbs) * C.sizeof_libxl_device_vfb))
	xc.num_vfbs = C.int(numVfbs)
	cVfbs := (*[1 << 28]C.libxl_device_vfb)(unsafe.Pointer(xc.vfbs))[:numVfbs:numVfbs]
	for i, v := range x.Vfbs {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cVfbs[i] = tmp
	}
	numVkbs := len(x.Vkbs)
	xc.vkbs = (*C.libxl_device_vkb)(C.malloc(C.ulong(numVkbs) * C.sizeof_libxl_device_vkb))
	xc.num_vkbs = C.int(numVkbs)
	cVkbs := (*[1 << 28]C.libxl_device_vkb)(unsafe.Pointer(xc.vkbs))[:numVkbs:numVkbs]
	for i, v := range x.Vkbs {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cVkbs[i] = tmp
	}
	numVtpms := len(x.Vtpms)
	xc.vtpms = (*C.libxl_device_vtpm)(C.malloc(C.ulong(numVtpms) * C.sizeof_libxl_device_vtpm))
	xc.num_vtpms = C.int(numVtpms)
	cVtpms := (*[1 << 28]C.libxl_device_vtpm)(unsafe.Pointer(xc.vtpms))[:numVtpms:numVtpms]
	for i, v := range x.Vtpms {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cVtpms[i] = tmp
	}
	numP9S := len(x.P9S)
	xc.p9s = (*C.libxl_device_p9)(C.malloc(C.ulong(numP9S) * C.sizeof_libxl_device_p9))
	xc.num_p9s = C.int(numP9S)
	cP9S := (*[1 << 28]C.libxl_device_p9)(unsafe.Pointer(xc.p9s))[:numP9S:numP9S]
	for i, v := range x.P9S {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cP9S[i] = tmp
	}
	numPvcallsifs := len(x.Pvcallsifs)
	xc.pvcallsifs = (*C.libxl_device_pvcallsif)(C.malloc(C.ulong(numPvcallsifs) * C.sizeof_libxl_device_pvcallsif))
	xc.num_pvcallsifs = C.int(numPvcallsifs)
	cPvcallsifs := (*[1 << 28]C.libxl_device_pvcallsif)(unsafe.Pointer(xc.pvcallsifs))[:numPvcallsifs:numPvcallsifs]
	for i, v := range x.Pvcallsifs {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cPvcallsifs[i] = tmp
	}
	numVdispls := len(x.Vdispls)
	xc.vdispls = (*C.libxl_device_vdispl)(C.malloc(C.ulong(numVdispls) * C.sizeof_libxl_device_vdispl))
	xc.num_vdispls = C.int(numVdispls)
	cVdispls := (*[1 << 28]C.libxl_device_vdispl)(unsafe.Pointer(xc.vdispls))[:numVdispls:numVdispls]
	for i, v := range x.Vdispls {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cVdispls[i] = tmp
	}
	numVsnds := len(x.Vsnds)
	xc.vsnds = (*C.libxl_device_vsnd)(C.malloc(C.ulong(numVsnds) * C.sizeof_libxl_device_vsnd))
	xc.num_vsnds = C.int(numVsnds)
	cVsnds := (*[1 << 28]C.libxl_device_vsnd)(unsafe.Pointer(xc.vsnds))[:numVsnds:numVsnds]
	for i, v := range x.Vsnds {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cVsnds[i] = tmp
	}
	numChannels := len(x.Channels)
	xc.channels = (*C.libxl_device_channel)(C.malloc(C.ulong(numChannels) * C.sizeof_libxl_device_channel))
	xc.num_channels = C.int(numChannels)
	cChannels := (*[1 << 28]C.libxl_device_channel)(unsafe.Pointer(xc.channels))[:numChannels:numChannels]
	for i, v := range x.Channels {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cChannels[i] = tmp
	}
	numUsbctrls := len(x.Usbctrls)
	xc.usbctrls = (*C.libxl_device_usbctrl)(C.malloc(C.ulong(numUsbctrls) * C.sizeof_libxl_device_usbctrl))
	xc.num_usbctrls = C.int(numUsbctrls)
	cUsbctrls := (*[1 << 28]C.libxl_device_usbctrl)(unsafe.Pointer(xc.usbctrls))[:numUsbctrls:numUsbctrls]
	for i, v := range x.Usbctrls {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cUsbctrls[i] = tmp
	}
	numUsbdevs := len(x.Usbdevs)
	xc.usbdevs = (*C.libxl_device_usbdev)(C.malloc(C.ulong(numUsbdevs) * C.sizeof_libxl_device_usbdev))
	xc.num_usbdevs = C.int(numUsbdevs)
	cUsbdevs := (*[1 << 28]C.libxl_device_usbdev)(unsafe.Pointer(xc.usbdevs))[:numUsbdevs:numUsbdevs]
	for i, v := range x.Usbdevs {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_domain_config_dispose(&xc)
			return xc, err
		}
		cUsbdevs[i] = tmp
	}
	xc.on_poweroff = C.libxl_action_on_shutdown(x.OnPoweroff)
	xc.on_reboot = C.libxl_action_on_shutdown(x.OnReboot)
	xc.on_watchdog = C.libxl_action_on_shutdown(x.OnWatchdog)
	xc.on_crash = C.libxl_action_on_shutdown(x.OnCrash)
	xc.on_soft_reset = C.libxl_action_on_shutdown(x.OnSoftReset)
	return xc, nil
}

func (x *Diskinfo) fromC(xc *C.libxl_diskinfo) error {
	x.Backend = C.GoString(xc.backend)
	x.BackendId = uint32(xc.backend_id)
	x.Frontend = C.GoString(xc.frontend)
	x.FrontendId = uint32(xc.frontend_id)
	x.Devid = Devid(xc.devid)
	x.State = int(xc.state)
	x.Evtch = int(xc.evtch)
	x.Rref = int(xc.rref)

	return nil
}

func (x *Diskinfo) toC() (xc C.libxl_diskinfo, err error) {
	C.libxl_diskinfo_init(&xc)
	xc.backend = C.CString(x.Backend)
	xc.backend_id = C.uint32_t(x.BackendId)
	xc.frontend = C.CString(x.Frontend)
	xc.frontend_id = C.uint32_t(x.FrontendId)
	xc.devid = C.libxl_devid(x.Devid)
	xc.state = C.int(x.State)
	xc.evtch = C.int(x.Evtch)
	xc.rref = C.int(x.Rref)
	return xc, nil
}

func (x *Nicinfo) fromC(xc *C.libxl_nicinfo) error {
	x.Backend = C.GoString(xc.backend)
	x.BackendId = uint32(xc.backend_id)
	x.Frontend = C.GoString(xc.frontend)
	x.FrontendId = uint32(xc.frontend_id)
	x.Devid = Devid(xc.devid)
	x.State = int(xc.state)
	x.Evtch = int(xc.evtch)
	x.RrefTx = int(xc.rref_tx)
	x.RrefRx = int(xc.rref_rx)

	return nil
}

func (x *Nicinfo) toC() (xc C.libxl_nicinfo, err error) {
	C.libxl_nicinfo_init(&xc)
	xc.backend = C.CString(x.Backend)
	xc.backend_id = C.uint32_t(x.BackendId)
	xc.frontend = C.CString(x.Frontend)
	xc.frontend_id = C.uint32_t(x.FrontendId)
	xc.devid = C.libxl_devid(x.Devid)
	xc.state = C.int(x.State)
	xc.evtch = C.int(x.Evtch)
	xc.rref_tx = C.int(x.RrefTx)
	xc.rref_rx = C.int(x.RrefRx)
	return xc, nil
}

func (x *Vtpminfo) fromC(xc *C.libxl_vtpminfo) error {
	x.Backend = C.GoString(xc.backend)
	x.BackendId = uint32(xc.backend_id)
	x.Frontend = C.GoString(xc.frontend)
	x.FrontendId = uint32(xc.frontend_id)
	x.Devid = Devid(xc.devid)
	x.State = int(xc.state)
	x.Evtch = int(xc.evtch)
	x.Rref = int(xc.rref)
	if err := x.Uuid.fromC(&xc.uuid); err != nil {
		return err
	}

	return nil
}

func (x *Vtpminfo) toC() (xc C.libxl_vtpminfo, err error) {
	C.libxl_vtpminfo_init(&xc)
	xc.backend = C.CString(x.Backend)
	xc.backend_id = C.uint32_t(x.BackendId)
	xc.frontend = C.CString(x.Frontend)
	xc.frontend_id = C.uint32_t(x.FrontendId)
	xc.devid = C.libxl_devid(x.Devid)
	xc.state = C.int(x.State)
	xc.evtch = C.int(x.Evtch)
	xc.rref = C.int(x.Rref)
	xc.uuid, err = x.Uuid.toC()
	if err != nil {
		C.libxl_vtpminfo_dispose(&xc)
		return xc, err
	}
	return xc, nil
}

func (x *Usbctrlinfo) fromC(xc *C.libxl_usbctrlinfo) error {
	x.Type = UsbctrlType(xc._type)
	x.Devid = Devid(xc.devid)
	x.Version = int(xc.version)
	x.Ports = int(xc.ports)
	x.Backend = C.GoString(xc.backend)
	x.BackendId = uint32(xc.backend_id)
	x.Frontend = C.GoString(xc.frontend)
	x.FrontendId = uint32(xc.frontend_id)
	x.State = int(xc.state)
	x.Evtch = int(xc.evtch)
	x.RefUrb = int(xc.ref_urb)
	x.RefConn = int(xc.ref_conn)

	return nil
}

func (x *Usbctrlinfo) toC() (xc C.libxl_usbctrlinfo, err error) {
	C.libxl_usbctrlinfo_init(&xc)
	xc._type = C.libxl_usbctrl_type(x.Type)
	xc.devid = C.libxl_devid(x.Devid)
	xc.version = C.int(x.Version)
	xc.ports = C.int(x.Ports)
	xc.backend = C.CString(x.Backend)
	xc.backend_id = C.uint32_t(x.BackendId)
	xc.frontend = C.CString(x.Frontend)
	xc.frontend_id = C.uint32_t(x.FrontendId)
	xc.state = C.int(x.State)
	xc.evtch = C.int(x.Evtch)
	xc.ref_urb = C.int(x.RefUrb)
	xc.ref_conn = C.int(x.RefConn)
	return xc, nil
}

func (x *Vcpuinfo) fromC(xc *C.libxl_vcpuinfo) error {
	x.Vcpuid = uint32(xc.vcpuid)
	x.Cpu = uint32(xc.cpu)
	x.Online = bool(xc.online)
	x.Blocked = bool(xc.blocked)
	x.Running = bool(xc.running)
	x.VcpuTime = uint64(xc.vcpu_time)
	if err := x.Cpumap.fromC(&xc.cpumap); err != nil {
		return err
	}
	if err := x.CpumapSoft.fromC(&xc.cpumap_soft); err != nil {
		return err
	}

	return nil
}

func (x *Vcpuinfo) toC() (xc C.libxl_vcpuinfo, err error) {
	C.libxl_vcpuinfo_init(&xc)
	xc.vcpuid = C.uint32_t(x.Vcpuid)
	xc.cpu = C.uint32_t(x.Cpu)
	xc.online = C.bool(x.Online)
	xc.blocked = C.bool(x.Blocked)
	xc.running = C.bool(x.Running)
	xc.vcpu_time = C.uint64_t(x.VcpuTime)
	xc.cpumap, err = x.Cpumap.toC()
	if err != nil {
		C.libxl_vcpuinfo_dispose(&xc)
		return xc, err
	}
	xc.cpumap_soft, err = x.CpumapSoft.toC()
	if err != nil {
		C.libxl_vcpuinfo_dispose(&xc)
		return xc, err
	}
	return xc, nil
}

func (x *Physinfo) fromC(xc *C.libxl_physinfo) error {
	x.ThreadsPerCore = uint32(xc.threads_per_core)
	x.CoresPerSocket = uint32(xc.cores_per_socket)
	x.MaxCpuId = uint32(xc.max_cpu_id)
	x.NrCpus = uint32(xc.nr_cpus)
	x.CpuKhz = uint32(xc.cpu_khz)
	x.TotalPages = uint64(xc.total_pages)
	x.FreePages = uint64(xc.free_pages)
	x.ScrubPages = uint64(xc.scrub_pages)
	x.OutstandingPages = uint64(xc.outstanding_pages)
	x.SharingFreedPages = uint64(xc.sharing_freed_pages)
	x.SharingUsedFrames = uint64(xc.sharing_used_frames)
	x.MaxPossibleMfn = uint64(xc.max_possible_mfn)
	x.NrNodes = uint32(xc.nr_nodes)
	if err := x.HwCap.fromC(&xc.hw_cap); err != nil {
		return err
	}
	x.CapHvm = bool(xc.cap_hvm)
	x.CapPv = bool(xc.cap_pv)
	x.CapHvmDirectio = bool(xc.cap_hvm_directio)
	x.CapHap = bool(xc.cap_hap)
	x.CapShadow = bool(xc.cap_shadow)
	x.CapIommuHapPtShare = bool(xc.cap_iommu_hap_pt_share)

	return nil
}

func (x *Physinfo) toC() (xc C.libxl_physinfo, err error) {
	C.libxl_physinfo_init(&xc)
	xc.threads_per_core = C.uint32_t(x.ThreadsPerCore)
	xc.cores_per_socket = C.uint32_t(x.CoresPerSocket)
	xc.max_cpu_id = C.uint32_t(x.MaxCpuId)
	xc.nr_cpus = C.uint32_t(x.NrCpus)
	xc.cpu_khz = C.uint32_t(x.CpuKhz)
	xc.total_pages = C.uint64_t(x.TotalPages)
	xc.free_pages = C.uint64_t(x.FreePages)
	xc.scrub_pages = C.uint64_t(x.ScrubPages)
	xc.outstanding_pages = C.uint64_t(x.OutstandingPages)
	xc.sharing_freed_pages = C.uint64_t(x.SharingFreedPages)
	xc.sharing_used_frames = C.uint64_t(x.SharingUsedFrames)
	xc.max_possible_mfn = C.uint64_t(x.MaxPossibleMfn)
	xc.nr_nodes = C.uint32_t(x.NrNodes)
	xc.hw_cap, err = x.HwCap.toC()
	if err != nil {
		C.libxl_physinfo_dispose(&xc)
		return xc, err
	}
	xc.cap_hvm = C.bool(x.CapHvm)
	xc.cap_pv = C.bool(x.CapPv)
	xc.cap_hvm_directio = C.bool(x.CapHvmDirectio)
	xc.cap_hap = C.bool(x.CapHap)
	xc.cap_shadow = C.bool(x.CapShadow)
	xc.cap_iommu_hap_pt_share = C.bool(x.CapIommuHapPtShare)
	return xc, nil
}

func (x *Connectorinfo) fromC(xc *C.libxl_connectorinfo) error {
	x.UniqueId = C.GoString(xc.unique_id)
	x.Width = uint32(xc.width)
	x.Height = uint32(xc.height)
	x.ReqEvtch = int(xc.req_evtch)
	x.ReqRref = int(xc.req_rref)
	x.EvtEvtch = int(xc.evt_evtch)
	x.EvtRref = int(xc.evt_rref)

	return nil
}

func (x *Connectorinfo) toC() (xc C.libxl_connectorinfo, err error) {
	C.libxl_connectorinfo_init(&xc)
	xc.unique_id = C.CString(x.UniqueId)
	xc.width = C.uint32_t(x.Width)
	xc.height = C.uint32_t(x.Height)
	xc.req_evtch = C.int(x.ReqEvtch)
	xc.req_rref = C.int(x.ReqRref)
	xc.evt_evtch = C.int(x.EvtEvtch)
	xc.evt_rref = C.int(x.EvtRref)
	return xc, nil
}

func (x *Vdisplinfo) fromC(xc *C.libxl_vdisplinfo) error {
	x.Backend = C.GoString(xc.backend)
	x.BackendId = uint32(xc.backend_id)
	x.Frontend = C.GoString(xc.frontend)
	x.FrontendId = uint32(xc.frontend_id)
	x.Devid = Devid(xc.devid)
	x.State = int(xc.state)
	x.BeAlloc = bool(xc.be_alloc)
	numConnectors := int(xc.num_connectors)
	cConnectors := (*[1 << 28]C.libxl_connectorinfo)(unsafe.Pointer(xc.connectors))[:numConnectors:numConnectors]
	x.Connectors = make([]Connectorinfo, numConnectors)
	for i, v := range cConnectors {
		var e Connectorinfo
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Connectors[i] = e
	}

	return nil
}

func (x *Vdisplinfo) toC() (xc C.libxl_vdisplinfo, err error) {
	C.libxl_vdisplinfo_init(&xc)
	xc.backend = C.CString(x.Backend)
	xc.backend_id = C.uint32_t(x.BackendId)
	xc.frontend = C.CString(x.Frontend)
	xc.frontend_id = C.uint32_t(x.FrontendId)
	xc.devid = C.libxl_devid(x.Devid)
	xc.state = C.int(x.State)
	xc.be_alloc = C.bool(x.BeAlloc)
	numConnectors := len(x.Connectors)
	xc.connectors = (*C.libxl_connectorinfo)(C.malloc(C.ulong(numConnectors) * C.sizeof_libxl_connectorinfo))
	xc.num_connectors = C.int(numConnectors)
	cConnectors := (*[1 << 28]C.libxl_connectorinfo)(unsafe.Pointer(xc.connectors))[:numConnectors:numConnectors]
	for i, v := range x.Connectors {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_vdisplinfo_dispose(&xc)
			return xc, err
		}
		cConnectors[i] = tmp
	}
	return xc, nil
}

func (x *Streaminfo) fromC(xc *C.libxl_streaminfo) error {
	x.ReqEvtch = int(xc.req_evtch)
	x.ReqRref = int(xc.req_rref)

	return nil
}

func (x *Streaminfo) toC() (xc C.libxl_streaminfo, err error) {
	C.libxl_streaminfo_init(&xc)
	xc.req_evtch = C.int(x.ReqEvtch)
	xc.req_rref = C.int(x.ReqRref)
	return xc, nil
}

func (x *Pcminfo) fromC(xc *C.libxl_pcminfo) error {
	numVsndStreams := int(xc.num_vsnd_streams)
	cStreams := (*[1 << 28]C.libxl_streaminfo)(unsafe.Pointer(xc.streams))[:numVsndStreams:numVsndStreams]
	x.Streams = make([]Streaminfo, numVsndStreams)
	for i, v := range cStreams {
		var e Streaminfo
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Streams[i] = e
	}

	return nil
}

func (x *Pcminfo) toC() (xc C.libxl_pcminfo, err error) {
	C.libxl_pcminfo_init(&xc)
	numVsndStreams := len(x.Streams)
	xc.streams = (*C.libxl_streaminfo)(C.malloc(C.ulong(numVsndStreams) * C.sizeof_libxl_streaminfo))
	xc.num_vsnd_streams = C.int(numVsndStreams)
	cStreams := (*[1 << 28]C.libxl_streaminfo)(unsafe.Pointer(xc.streams))[:numVsndStreams:numVsndStreams]
	for i, v := range x.Streams {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_pcminfo_dispose(&xc)
			return xc, err
		}
		cStreams[i] = tmp
	}
	return xc, nil
}

func (x *Vsndinfo) fromC(xc *C.libxl_vsndinfo) error {
	x.Backend = C.GoString(xc.backend)
	x.BackendId = uint32(xc.backend_id)
	x.Frontend = C.GoString(xc.frontend)
	x.FrontendId = uint32(xc.frontend_id)
	x.Devid = Devid(xc.devid)
	x.State = int(xc.state)
	numVsndPcms := int(xc.num_vsnd_pcms)
	cPcms := (*[1 << 28]C.libxl_pcminfo)(unsafe.Pointer(xc.pcms))[:numVsndPcms:numVsndPcms]
	x.Pcms = make([]Pcminfo, numVsndPcms)
	for i, v := range cPcms {
		var e Pcminfo
		if err := e.fromC(&v); err != nil {
			return err
		}
		x.Pcms[i] = e
	}

	return nil
}

func (x *Vsndinfo) toC() (xc C.libxl_vsndinfo, err error) {
	C.libxl_vsndinfo_init(&xc)
	xc.backend = C.CString(x.Backend)
	xc.backend_id = C.uint32_t(x.BackendId)
	xc.frontend = C.CString(x.Frontend)
	xc.frontend_id = C.uint32_t(x.FrontendId)
	xc.devid = C.libxl_devid(x.Devid)
	xc.state = C.int(x.State)
	numVsndPcms := len(x.Pcms)
	xc.pcms = (*C.libxl_pcminfo)(C.malloc(C.ulong(numVsndPcms) * C.sizeof_libxl_pcminfo))
	xc.num_vsnd_pcms = C.int(numVsndPcms)
	cPcms := (*[1 << 28]C.libxl_pcminfo)(unsafe.Pointer(xc.pcms))[:numVsndPcms:numVsndPcms]
	for i, v := range x.Pcms {
		tmp, err := v.toC()
		if err != nil {
			C.libxl_vsndinfo_dispose(&xc)
			return xc, err
		}
		cPcms[i] = tmp
	}
	return xc, nil
}

func (x *Vkbinfo) fromC(xc *C.libxl_vkbinfo) error {
	x.Backend = C.GoString(xc.backend)
	x.BackendId = uint32(xc.backend_id)
	x.Frontend = C.GoString(xc.frontend)
	x.FrontendId = uint32(xc.frontend_id)
	x.Devid = Devid(xc.devid)
	x.State = int(xc.state)
	x.Evtch = int(xc.evtch)
	x.Rref = int(xc.rref)

	return nil
}

func (x *Vkbinfo) toC() (xc C.libxl_vkbinfo, err error) {
	C.libxl_vkbinfo_init(&xc)
	xc.backend = C.CString(x.Backend)
	xc.backend_id = C.uint32_t(x.BackendId)
	xc.frontend = C.CString(x.Frontend)
	xc.frontend_id = C.uint32_t(x.FrontendId)
	xc.devid = C.libxl_devid(x.Devid)
	xc.state = C.int(x.State)
	xc.evtch = C.int(x.Evtch)
	xc.rref = C.int(x.Rref)
	return xc, nil
}

func (x *Numainfo) fromC(xc *C.libxl_numainfo) error {
	x.Size = uint64(xc.size)
	x.Free = uint64(xc.free)
	numDists := int(xc.num_dists)
	cDists := (*[1 << 28]C.uint32_t)(unsafe.Pointer(xc.dists))[:numDists:numDists]
	x.Dists = make([]uint32, numDists)
	for i, v := range cDists {
		x.Dists[i] = uint32(v)
	}

	return nil
}

func (x *Numainfo) toC() (xc C.libxl_numainfo, err error) {
	C.libxl_numainfo_init(&xc)
	xc.size = C.uint64_t(x.Size)
	xc.free = C.uint64_t(x.Free)
	numDists := len(x.Dists)
	xc.dists = (*C.uint32_t)(C.malloc(C.size_t(numDists * numDists)))
	xc.num_dists = C.int(numDists)
	cDists := (*[1 << 28]C.uint32_t)(unsafe.Pointer(xc.dists))[:numDists:numDists]
	for i, v := range x.Dists {
		cDists[i] = C.uint32_t(v)
	}
	return xc, nil
}

func (x *Cputopology) fromC(xc *C.libxl_cputopology) error {
	x.Core = uint32(xc.core)
	x.Socket = uint32(xc.socket)
	x.Node = uint32(xc.node)

	return nil
}

func (x *Cputopology) toC() (xc C.libxl_cputopology, err error) {
	C.libxl_cputopology_init(&xc)
	xc.core = C.uint32_t(x.Core)
	xc.socket = C.uint32_t(x.Socket)
	xc.node = C.uint32_t(x.Node)
	return xc, nil
}

func (x *Pcitopology) fromC(xc *C.libxl_pcitopology) error {
	x.Seg = uint16(xc.seg)
	x.Bus = byte(xc.bus)
	x.Devfn = byte(xc.devfn)
	x.Node = uint32(xc.node)

	return nil
}

func (x *Pcitopology) toC() (xc C.libxl_pcitopology, err error) {
	C.libxl_pcitopology_init(&xc)
	xc.seg = C.uint16_t(x.Seg)
	xc.bus = C.uint8_t(x.Bus)
	xc.devfn = C.uint8_t(x.Devfn)
	xc.node = C.uint32_t(x.Node)
	return xc, nil
}

func (x *SchedCreditParams) fromC(xc *C.libxl_sched_credit_params) error {
	x.TsliceMs = int(xc.tslice_ms)
	x.RatelimitUs = int(xc.ratelimit_us)
	x.VcpuMigrDelayUs = int(xc.vcpu_migr_delay_us)

	return nil
}

func (x *SchedCreditParams) toC() (xc C.libxl_sched_credit_params, err error) {
	C.libxl_sched_credit_params_init(&xc)
	xc.tslice_ms = C.int(x.TsliceMs)
	xc.ratelimit_us = C.int(x.RatelimitUs)
	xc.vcpu_migr_delay_us = C.int(x.VcpuMigrDelayUs)
	return xc, nil
}

func (x *SchedCredit2Params) fromC(xc *C.libxl_sched_credit2_params) error {
	x.RatelimitUs = int(xc.ratelimit_us)

	return nil
}

func (x *SchedCredit2Params) toC() (xc C.libxl_sched_credit2_params, err error) {
	C.libxl_sched_credit2_params_init(&xc)
	xc.ratelimit_us = C.int(x.RatelimitUs)
	return xc, nil
}

func (x *DomainRemusInfo) fromC(xc *C.libxl_domain_remus_info) error {
	x.Interval = int(xc.interval)
	if err := x.AllowUnsafe.fromC(&xc.allow_unsafe); err != nil {
		return err
	}
	if err := x.Blackhole.fromC(&xc.blackhole); err != nil {
		return err
	}
	if err := x.Compression.fromC(&xc.compression); err != nil {
		return err
	}
	if err := x.Netbuf.fromC(&xc.netbuf); err != nil {
		return err
	}
	x.Netbufscript = C.GoString(xc.netbufscript)
	if err := x.Diskbuf.fromC(&xc.diskbuf); err != nil {
		return err
	}
	if err := x.Colo.fromC(&xc.colo); err != nil {
		return err
	}
	if err := x.UserspaceColoProxy.fromC(&xc.userspace_colo_proxy); err != nil {
		return err
	}

	return nil
}

func (x *DomainRemusInfo) toC() (xc C.libxl_domain_remus_info, err error) {
	C.libxl_domain_remus_info_init(&xc)
	xc.interval = C.int(x.Interval)
	xc.allow_unsafe, err = x.AllowUnsafe.toC()
	if err != nil {
		C.libxl_domain_remus_info_dispose(&xc)
		return xc, err
	}
	xc.blackhole, err = x.Blackhole.toC()
	if err != nil {
		C.libxl_domain_remus_info_dispose(&xc)
		return xc, err
	}
	xc.compression, err = x.Compression.toC()
	if err != nil {
		C.libxl_domain_remus_info_dispose(&xc)
		return xc, err
	}
	xc.netbuf, err = x.Netbuf.toC()
	if err != nil {
		C.libxl_domain_remus_info_dispose(&xc)
		return xc, err
	}
	xc.netbufscript = C.CString(x.Netbufscript)
	xc.diskbuf, err = x.Diskbuf.toC()
	if err != nil {
		C.libxl_domain_remus_info_dispose(&xc)
		return xc, err
	}
	xc.colo, err = x.Colo.toC()
	if err != nil {
		C.libxl_domain_remus_info_dispose(&xc)
		return xc, err
	}
	xc.userspace_colo_proxy, err = x.UserspaceColoProxy.toC()
	if err != nil {
		C.libxl_domain_remus_info_dispose(&xc)
		return xc, err
	}
	return xc, nil
}

func (x *Event) fromC(xc *C.libxl_event) error {
	if err := x.Link.fromC(&xc.link); err != nil {
		return err
	}
	x.Domid = Domid(xc.domid)
	if err := x.Domuuid.fromC(&xc.domuuid); err != nil {
		return err
	}
	x.ForUser = uint64(xc.for_user)
	x.Type = EventType(xc._type)
	switch x.Type {
	case EventTypeOperationComplete:
		var typeOperationComplete EventTypeUnionOperationComplete
		if err := typeOperationComplete.fromC(xc); err != nil {
			return err
		}
		x.TypeUnion = typeOperationComplete
	case EventTypeDomainShutdown:
		var typeDomainShutdown EventTypeUnionDomainShutdown
		if err := typeDomainShutdown.fromC(xc); err != nil {
			return err
		}
		x.TypeUnion = typeDomainShutdown
	case EventTypeDiskEject:
		var typeDiskEject EventTypeUnionDiskEject
		if err := typeDiskEject.fromC(xc); err != nil {
			return err
		}
		x.TypeUnion = typeDiskEject
	default:
		return fmt.Errorf("invalid union key '%v'", x.Type)
	}

	return nil
}

func (x *EventTypeUnionDomainShutdown) fromC(xc *C.libxl_event) error {
	if EventType(xc._type) != EventTypeDomainShutdown {
		return errors.New("expected union key EventTypeDomainShutdown")
	}

	tmp := (*C.libxl_event_type_union_domain_shutdown)(unsafe.Pointer(&xc.u[0]))
	x.ShutdownReason = byte(tmp.shutdown_reason)
	return nil
}

func (x *EventTypeUnionDiskEject) fromC(xc *C.libxl_event) error {
	if EventType(xc._type) != EventTypeDiskEject {
		return errors.New("expected union key EventTypeDiskEject")
	}

	tmp := (*C.libxl_event_type_union_disk_eject)(unsafe.Pointer(&xc.u[0]))
	x.Vdev = C.GoString(tmp.vdev)
	if err := x.Disk.fromC(&tmp.disk); err != nil {
		return err
	}
	return nil
}

func (x *EventTypeUnionOperationComplete) fromC(xc *C.libxl_event) error {
	if EventType(xc._type) != EventTypeOperationComplete {
		return errors.New("expected union key EventTypeOperationComplete")
	}

	tmp := (*C.libxl_event_type_union_operation_complete)(unsafe.Pointer(&xc.u[0]))
	x.Rc = int(tmp.rc)
	return nil
}

func (x *Event) toC() (xc C.libxl_event, err error) {
	C.libxl_event_init(&xc)
	xc.link, err = x.Link.toC()
	if err != nil {
		C.libxl_event_dispose(&xc)
		return xc, err
	}
	xc.domid = C.libxl_domid(x.Domid)
	xc.domuuid, err = x.Domuuid.toC()
	if err != nil {
		C.libxl_event_dispose(&xc)
		return xc, err
	}
	xc.for_user = C.uint64_t(x.ForUser)
	xc._type = C.libxl_event_type(x.Type)
	switch x.Type {
	case EventTypeDomainShutdown:
		tmp, ok := x.TypeUnion.(EventTypeUnionDomainShutdown)
		if !ok {
			C.libxl_event_dispose(&xc)
			return xc, errors.New("wrong type for union key type")
		}
		var domain_shutdown C.libxl_event_type_union_domain_shutdown
		domain_shutdown.shutdown_reason = C.uint8_t(tmp.ShutdownReason)
		domain_shutdownBytes := C.GoBytes(unsafe.Pointer(&domain_shutdown), C.sizeof_libxl_event_type_union_domain_shutdown)
		copy(xc.u[:], domain_shutdownBytes)
	case EventTypeDiskEject:
		tmp, ok := x.TypeUnion.(EventTypeUnionDiskEject)
		if !ok {
			C.libxl_event_dispose(&xc)
			return xc, errors.New("wrong type for union key type")
		}
		var disk_eject C.libxl_event_type_union_disk_eject
		disk_eject.vdev = C.CString(tmp.Vdev)
		disk_eject.disk, err = tmp.Disk.toC()
		if err != nil {
			C.libxl_event_dispose(&xc)
			return xc, err
		}
		disk_ejectBytes := C.GoBytes(unsafe.Pointer(&disk_eject), C.sizeof_libxl_event_type_union_disk_eject)
		copy(xc.u[:], disk_ejectBytes)
	case EventTypeOperationComplete:
		tmp, ok := x.TypeUnion.(EventTypeUnionOperationComplete)
		if !ok {
			C.libxl_event_dispose(&xc)
			return xc, errors.New("wrong type for union key type")
		}
		var operation_complete C.libxl_event_type_union_operation_complete
		operation_complete.rc = C.int(tmp.Rc)
		operation_completeBytes := C.GoBytes(unsafe.Pointer(&operation_complete), C.sizeof_libxl_event_type_union_operation_complete)
		copy(xc.u[:], operation_completeBytes)
	default:
		return xc, fmt.Errorf("invalid union key '%v'", x.Type)
	}
	return xc, nil
}

func (x *PsrCatInfo) fromC(xc *C.libxl_psr_cat_info) error {
	x.Id = uint32(xc.id)
	x.CosMax = uint32(xc.cos_max)
	x.CbmLen = uint32(xc.cbm_len)
	x.CdpEnabled = bool(xc.cdp_enabled)

	return nil
}

func (x *PsrCatInfo) toC() (xc C.libxl_psr_cat_info, err error) {
	C.libxl_psr_cat_info_init(&xc)
	xc.id = C.uint32_t(x.Id)
	xc.cos_max = C.uint32_t(x.CosMax)
	xc.cbm_len = C.uint32_t(x.CbmLen)
	xc.cdp_enabled = C.bool(x.CdpEnabled)
	return xc, nil
}

func (x *PsrHwInfo) fromC(xc *C.libxl_psr_hw_info) error {
	x.Id = uint32(xc.id)
	x.Type = PsrFeatType(xc._type)
	switch x.Type {
	case PsrFeatTypeMba:
		var typeMba PsrHwInfoTypeUnionMba
		if err := typeMba.fromC(xc); err != nil {
			return err
		}
		x.TypeUnion = typeMba
	case PsrFeatTypeCat:
		var typeCat PsrHwInfoTypeUnionCat
		if err := typeCat.fromC(xc); err != nil {
			return err
		}
		x.TypeUnion = typeCat
	default:
		return fmt.Errorf("invalid union key '%v'", x.Type)
	}

	return nil
}

func (x *PsrHwInfoTypeUnionCat) fromC(xc *C.libxl_psr_hw_info) error {
	if PsrFeatType(xc._type) != PsrFeatTypeCat {
		return errors.New("expected union key PsrFeatTypeCat")
	}

	tmp := (*C.libxl_psr_hw_info_type_union_cat)(unsafe.Pointer(&xc.u[0]))
	x.CosMax = uint32(tmp.cos_max)
	x.CbmLen = uint32(tmp.cbm_len)
	x.CdpEnabled = bool(tmp.cdp_enabled)
	return nil
}

func (x *PsrHwInfoTypeUnionMba) fromC(xc *C.libxl_psr_hw_info) error {
	if PsrFeatType(xc._type) != PsrFeatTypeMba {
		return errors.New("expected union key PsrFeatTypeMba")
	}

	tmp := (*C.libxl_psr_hw_info_type_union_mba)(unsafe.Pointer(&xc.u[0]))
	x.CosMax = uint32(tmp.cos_max)
	x.ThrtlMax = uint32(tmp.thrtl_max)
	x.Linear = bool(tmp.linear)
	return nil
}

func (x *PsrHwInfo) toC() (xc C.libxl_psr_hw_info, err error) {
	C.libxl_psr_hw_info_init(&xc)
	xc.id = C.uint32_t(x.Id)
	xc._type = C.libxl_psr_feat_type(x.Type)
	switch x.Type {
	case PsrFeatTypeCat:
		tmp, ok := x.TypeUnion.(PsrHwInfoTypeUnionCat)
		if !ok {
			C.libxl_psr_hw_info_dispose(&xc)
			return xc, errors.New("wrong type for union key type")
		}
		var cat C.libxl_psr_hw_info_type_union_cat
		cat.cos_max = C.uint32_t(tmp.CosMax)
		cat.cbm_len = C.uint32_t(tmp.CbmLen)
		cat.cdp_enabled = C.bool(tmp.CdpEnabled)
		catBytes := C.GoBytes(unsafe.Pointer(&cat), C.sizeof_libxl_psr_hw_info_type_union_cat)
		copy(xc.u[:], catBytes)
	case PsrFeatTypeMba:
		tmp, ok := x.TypeUnion.(PsrHwInfoTypeUnionMba)
		if !ok {
			C.libxl_psr_hw_info_dispose(&xc)
			return xc, errors.New("wrong type for union key type")
		}
		var mba C.libxl_psr_hw_info_type_union_mba
		mba.cos_max = C.uint32_t(tmp.CosMax)
		mba.thrtl_max = C.uint32_t(tmp.ThrtlMax)
		mba.linear = C.bool(tmp.Linear)
		mbaBytes := C.GoBytes(unsafe.Pointer(&mba), C.sizeof_libxl_psr_hw_info_type_union_mba)
		copy(xc.u[:], mbaBytes)
	default:
		return xc, fmt.Errorf("invalid union key '%v'", x.Type)
	}
	return xc, nil
}
